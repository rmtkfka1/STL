//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 5일 화요일  (1주 1 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	/*for (char c : v)
	{
		cout << c;
	}*/

	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 5일 화요일  (1주 1 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	/*for (char c : v)
	{
		cout << c;
	}*/

	out << endl << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto time = chrono::system_clock::now(); // epoch 으로부터 흐른 tick

	cout << time << endl;

	// 2.시간형식으로 변환
	// 3.현지 시간으로 바꾼다.
	// 4.한국 형식으로 출력한다.
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : " << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto time = chrono::system_clock::now(); // epoch 으로부터 흐른 tick

	cout << time << endl;

	// 2.시간형식으로 변환
	// 3.현지 시간으로 바꾼다.
	// 4.한국 형식으로 출력한다.
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : " << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);

	cout << utc_time << endl;
	// 3.현지 시간으로 바꾼다.
	// 4.한국 형식으로 출력한다.
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : " << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 03/07/24 Thursday 13:45:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5. 시간을 기록한다.
	// 
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : "<<put_time(lt,"%x %A %X") << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
저장된 시간 : 2024-03-07 목요일 오후 1:47:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : "<<put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;


	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
저장된 시간 : 2024-03-07 목요일 오후 1:49:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5.시간을 출력한다.
	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : "<<put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5.시간을 출력한다.
	out << endl << endl;
	out << "=============================================== " << endl;
	//out << "저장된 시간 : "<<put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
STL.cpp 2024-03-07 목요일 오후 1:52:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5.시간을 출력한다.
	out << endl << endl;
	out << "=============================================== " << endl;
	out << fileName<<" " << put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
STL.cpp 2024-03-07 목요일 오후 1:56:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include "save.h"

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 1:57:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:02:21
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:03:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
save.h 2024-03-07 목요일 오후 2:07:24
=============================================== 

#pragma once
#include <string_view>

//-----------------------------------------------------------------------------------------
// save.h 한학기 강의를 저장한다.
// 
// 2024 . 03 .07 
//------------------------------------------------------------------------------------------

void save(std::string_view fileName);

=============================================== 
save.cpp 2024-03-07 목요일 오후 2:07:24
=============================================== 

#include "save.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
		ifstream in{ fileName.data() }; //RAII

		if (!in)
		{
			cout << fileName << " 열기 실패" << endl;
			exit(0);
		}

		//cout << sizeof(in) << endl;
		//cout << addressof(in) << endl;
		//cout << typeid(in).name() << endl;



		// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

		ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



		// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
		//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

		vector<char> v{ istreambuf_iterator<char>{in},{} };

		// ====================시간 출력하는 방법=========================//
		// 1.현재 time_point 를 얻는다.
		auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
		// 2.UTC 시간형식으로 변환
		auto utc_time = chrono::system_clock::to_time_t(now);
		// 3.현지 시간으로 바꾼다.
		auto lt = localtime(&utc_time);
		// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
		auto old = out.imbue(locale("ko_KR"));
		// 5.시간을 출력한다.
		out << endl << endl;
		out << "=============================================== " << endl;
		out << fileName << " " << put_time(lt, "%x %A %X") << endl;
		out << "=============================================== " << endl;
		// 6.다시 원상복구한다.
		out.imbue(locale(old));
		// ===================================================//
		out << endl;
		copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:07:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " save 기능을 완성했다." << endl;
	save("save.h");
	save("save.cpp");
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:26:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.


void change(int& n1, int& n2)
{
	swap(n1, n2);
}


int main()
{
	int a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:37:17
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


int main()
{
	int a{ 1 }, b{ 2 };


	change<int>(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:53:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog {
public:
	Dog(int a) : t(a) {}

	int getValue() const {
		return t;
	}

private:
	int t;
};


std::ostream& operator<<(std::ostream& os, const Dog& dog) {
	os << dog.getValue(); 
	return os;
}



int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:05:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  

	int getValue() const {
		return t;
	}

	operator int() { return t; }


private:
	int t;
};


//std::ostream& operator<<(std::ostream& os, const Dog& dog) {
//	os << dog.getValue(); 
//	return os;
//}



int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:08:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  

	int getValue() const {
		return t;
	}

	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.getValue();
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:20:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t << endl;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:20:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:18:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:26:14
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:26:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a(1), b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:48:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <vector>
using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.


//generic programing -> 자료형에 무관한 코딩
template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};


int main()
{

	Dog a{  1 }, b{ 2 };

	change(a, b);
	//우선순위 1. change(dog , dog ) 가존재하나 ? 2. change(dog&, dog& ) 가 존재하나?
	//         3. 템플릿 코드 확장 

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<" ";
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<" ";
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<endl;
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:53:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 2);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<endl;
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:53:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 5);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<endl;
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:01:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<< '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:04:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:04:30
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:<80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:04:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:^80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:^80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:^8}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:8}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:8}",a[i]) << '\t';
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:06:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		print(cout, "{:8}", a[i]);
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:07:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		print(cout, "{:8}", a[i]);
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:07:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{

	const int num = 100;

	int a[num];

	for (int i = 0; i < num; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < num; ++i)
	{
		print(cout, "{:8}", a[i]);
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:12:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) 
// 
//[문제] int 1000개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 1000개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:13:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) 
// 
//[문제] int 1000개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 1000개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{


	int a[100];

	for (int i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:16:27
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	/*for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;*/

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout << max << endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:16:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:16:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[10];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:17:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[10];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;
	cout << endl;
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:17:17
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[10];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;
	cout << endl;
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:24:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:25:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:25:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:25:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:30:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	{
		int max = numeric_limits<int>::min();

		for (int i : a)
		{
			if (i > max)
			{
				max = i;
			}
		}

		cout << max << endl;
	}
	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:32:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	auto result = max_element(begin(a), end(a));

	cout << result << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:32:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	auto result = max_element(begin(a), end(a));

	cout << *result << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:35:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	auto result = max_element(begin(a), end(a));

	cout << *result << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:36:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	cout << *max_element(begin(a), end(a)) << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:39:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	cout << *max_element(begin(a), end(a)) << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:40:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용


	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	cout << *max_element(a.begin(), a.end()) << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:42:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	sizeof(a);


	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	cout << *max_element(a.begin(), a.end()) << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:47:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>
#include <fstream>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	//[문제] 파일 "int값들.txt 에 a 의 int 값을 모두 저장하라.
	// 
	// 
	ofstream out{ "int값들.txt" };

	if (out.is_open())
	{
		for (int i : a)
		{
			out << i;
		}
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:48:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>
#include <fstream>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	//[문제] 파일 "int값들.txt 에 a 의 int 값을 모두 저장하라.
	// 
	// 
	ofstream out{ "int값들.txt" };

	if (out.is_open())
	{
		for (int i : a)
		{
			out << i<<endl;
		}
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:56:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <fstream>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	//[문제] 파일 "int값들.txt 에 a 의 int 값을 모두 저장하라.
	// 
	// 
	ofstream out{ "int값들.txt" }; //RAII


	for (int i : a)
	{
		print(out, "{:8}", i);
	};
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:04:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		int num;
		int count{};
		while (in >> num)
		{
			++count;
			cout << "개수"  << endl;
		};


	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:04:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		int num;
		int count{};
		while (in >> num)
		{
			++count;
			cout << "개수" << count  << endl;
		};


	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:05:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		int num;
		int max = numeric_limits<int>::min();
		while (in >> num)
		{
			if (max < num)
			{
				max = num;
			}
		};

		cout << "최댓값:" << max << endl;


	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:08:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		/*int num;
		int max = numeric_limits<int>::min();
		while (in >> num)
		{
			if (max < num)
			{
				max = num;
			}
		};*/
		cout << *max_element(istream_iterator<int>{in}, {}) << endl;
		
		

	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:29:21
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		/*int num;
		int max = numeric_limits<int>::min();
		while (in >> num)
		{
			if (max < num)
			{
				max = num;
			}
		};*/
		cout << *max_element(istream_iterator<int>(in), {}) << endl;
		
		

	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:36:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 1; i <= 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:37:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 1; i < 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:37:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 1; i < 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:57
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a{};

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:39:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a{1};

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:39:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a{1,100};

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:40:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

array<int, 100> a;

int main()
{
	

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:42:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a;

	for (int& i: a)
	{
		i = i + 1;
	}

	/*for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}*/

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:42:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a;

	for (int& i: a)
	{
		cout << i << endl;
		i = i + 1;
	}

	/*for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}*/

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:44:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};


	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:46:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	int count = 0;

	for (int& num : a)
	{
		num = count++;
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:47:00
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	int count = 0;

	for (int& num : a)
	{
		num = ++count;
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:54:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);
	

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:57:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

	cout << *max_element(a.begin(), a.end()) << endl;
	
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:57:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end()-3, 1);

	cout << *max_element(a.begin(), a.end()) << endl;
	
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:02:40
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		print(out, "{:8}", i);
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:04:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		print(out, "{} ", i);
	}

	//int 100개를 저장하기 위해 필요한 공간은 ?





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:25:21
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		print(out, "{} ", i);
	}

	//int 100개를 저장하기 위해 필요한 공간은 ? 
	// simple 단순그자체로 파일에기록 ( 400바이트 그대로옴겨다적음)-> 저수준 출력
	// 함수 ( 어디에 ,무엇을 ) == 함수(out,a.data(),400);  DMA 코드

	out.write((char*)(a.data()), a.size()*sizeof(int));





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:25:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	/*for (int i : a)
	{
		print(out, "{} ", i);
	}*/

	//int 100개를 저장하기 위해 필요한 공간은 ? 
	// simple 단순그자체로 파일에기록 ( 400바이트 그대로옴겨다적음)-> 저수준 출력
	// 함수 ( 어디에 ,무엇을 ) == 함수(out,a.data(),400);  DMA 코드

	out.write((char*)(a.data()), a.size()*sizeof(int));





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:36:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:36:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:43:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;


default_random_engine dre; 
uniform_int_distribution uid;

//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 1000> a{};

	for (int& num : a)
	{
		num = uid(dre);
	}

	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:44:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 100> a{};

	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	//out.write((char*)(a.data()), a.size()*sizeof(int));

	for (int i = 0; i < 100; ++i)
	{
		out << a[i] << endl;
	}
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:44:30
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 100> a{};

	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt"};

	//out.write((char*)(a.data()), a.size()*sizeof(int));

	for (int i = 0; i < 100; ++i)
	{
		out << a[i] << endl;
	}
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:44:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 100> a{};

	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	//out.write((char*)(a.data()), a.size()*sizeof(int));

	for (int i = 0; i < 100; ++i)
	{
		out << a[i] << endl;
	}
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:46:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로)




int main()
{
	array<int, 1000> a{};

	for (int& num : a)
	{
		num = uid(dre);
	}
	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:47:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로)




int main()
{
	array<int, 1000> a{};

	for (int& num : a)
	{
		num = uid(dre);
	}
	ofstream out{"int값들",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:55:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	ifstream in("int값들", ios::binary);


	int buffer[1000] = {};

	in.read((char*)buffer, sizeof(buffer));

	cout << buffer[0] << endl;





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:57:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	ifstream in("int값들", ios::binary);


	array<int,1000> buffer;

	in.read((char*)buffer.data(), sizeof(buffer));


	cout << *max_element(buffer.begin(), buffer.end());





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:00:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	//내가 한 코딩
	// ========================================================================
	//ifstream in("int값들", ios::binary);

	//array<int,1000> buffer;

	//in.read((char*)buffer.data(), sizeof(buffer));


	//cout << *max_element(begin(buffer), buffer.end());
	//==========================================================================

	ifstream fin{ "int값들" ,ios::binary };

	if (!fin.is_open())
	{
		cout << "없다" << endl;
		return 0;
	}

	int num;
	int max= numeric_limits<int>::min();
	for (int i = 0; i < 1000; ++i)
	{
		fin.read((char*) & num, sizeof(num));
		
		if (num > max)
		{
			max = num;
		}
	}

	cout << max << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:01:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	//내가 한 코딩
	// ========================================================================
	ifstream in("int값들", ios::binary);

	array<int,1000> buffer;

	in.read((char*)buffer.data(), sizeof(buffer));


	cout << *max_element(begin(buffer), buffer.end());
	//==========================================================================

	//ifstream fin{ "int값들" ,ios::binary };

	//if (!fin.is_open())
	//{
	//	cout << "없다" << endl;
	//	return 0;
	//}

	//int num;
	//int max= numeric_limits<int>::min();
	//for (int i = 0; i < 1000; ++i)
	//{
	//	fin.read((char*) & num, sizeof(num));
	//	
	//	if (num > max)
	//	{
	//		max = num;
	//	}
	//}

	//cout << max << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:03:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	//내가 한 코딩
	// ========================================================================
	//ifstream in("int값들", ios::binary);

	//array<int,1000> buffer;

	//in.read((char*)buffer.data(), sizeof(buffer));


	//cout << *max_element(begin(buffer), buffer.end());
	//==========================================================================

	ifstream fin{ "int값들" ,ios::binary };

	if (!fin.is_open())
	{
		cout << "없다" << endl;
		return 0;
	}


	array<int,1000> buffer;

	fin.read(reinterpret_cast<char*>(buffer.data()), sizeof(buffer));

	cout << *max_element(begin(buffer), buffer.end());



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:08:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num << endl;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre)) };

	int num = { uidNum(dre) };
};


int main()
{
	

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:09:35
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num << endl;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:09:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:11:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	//기록
	ofstream out{ "개들",ios::binary };

	out.write((char*)dogs.data(), sizeof(dogs) * dogs.size());


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:12:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	//기록
	ofstream out{ "개들",ios::binary };

	out.write((char*)dogs.data(), sizeof(Dog) * dogs.size());


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:51:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	Dog dog;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(&dog), sizeof(dog));
		dog.show();
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:53:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(dogs.data()), sizeof(Dog)*100);
	}

	for (int i = 0; i < 100; ++i)
	{
		dogs[i].show();
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:53:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(dogs.data()), sizeof(Dog)*100);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << i << ":" << *dogs.data() << endl;
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:54:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(dogs.data()), sizeof(Dog)*100);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << i;
		dogs[i].show();
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:57:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	fin.read((char*)&dogs, sizeof(Dog) * 100);

	for (const Dog& dog : dogs)
	{
		dog.show();
	}



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:57:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	fin.read((char*)&dogs, sizeof(Dog) * 100);

	for (const Dog& dog : dogs)
	{
		dog.show();
	}



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:11:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 몇개인지 모르는 class Dog 객체 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}






private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	//in파일의 크기를 filesystem 을 이용하여 얻는다
	//파일사이즈 /sieof(Dog) -> 100개 
	//runtime 중에  100개가 결정되면 메모리할당? ==> new Dog[100]


	Dog dog;
	int cnt{};

	while (fin >> dog)
	{
		++cnt;
	}

	cout << "읽은 도그의 갯수 :" << cnt << endl;
	dog.show();  // -> 100번 ┚셈 정보



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:20:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	int maxValue = numeric_limits<int>::min();


	//안좋은 코딩의 예시 

	Dog tempDog;

	for (const Dog& dog : dogs)
	{
	/*	cout << dog.Getnum() << endl;*/

		if (dog.Getnum() > maxValue)
		{
			maxValue = dog.Getnum();
			tempDog = dog;
		}
	}

	cout << tempDog << endl;
	cout << maxValue << endl;







	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:39:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	cout << *max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.Getnum() <= b.Getnum();
		}) << endl;






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:42:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	 max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.Getnum() <= b.Getnum();
		 })->show();






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:43:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	auto it = max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.Getnum() <= b.Getnum();
		});

	it->show();






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:49:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 10000 미만인 Dog 객체는 몇개인지 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);

	int cnt{};
	for (const Dog& dog : dogs)
	{
		if (dog.Getnum() < 10000)
		{
			cnt++;
		}
	}

	cout << cnt << endl;






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 3:01:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 10000 미만인 Dog 객체는 몇개인지 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);

	auto val = count_if(dogs.begin(), dogs.end(), [](const Dog& a) {
		return a.Getnum() < 10000;
		});

	cout << val << endl;



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 3:02:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 10000 미만인 Dog 객체는 몇개인지 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);

	auto val = count_if(dogs.begin(), dogs.end(), [](const Dog& a) {
		if (a.Getnum() < 10000)
		{
			return true;
		}
		return false;
		});

	cout << val << endl;



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:34:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;



int main()
{
	array<float, 10> a;


	cout << "==" << addressof(a) << endl;

	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:36:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;



int main()
{
	array<float, 10> a;


	cout << "==" << addressof(a) << endl;
	cout << &a << endl;
	cout << a.data() << endl;
	cout << &a[0] << endl;
	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:37:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;



int main()
{
	array<float, 10> a;


	cout << "==" << addressof(a) << endl;
	cout << &a << endl;
	cout << a.data() << endl;
	cout << &a[0] << endl;
	//for (const auto& v : a)
	//{
	//	cout << addressof(v) << endl;
	//}
	

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:40:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;



int main()
{
	array<float, 10> a;

	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	
	cout << "===========================" << endl;
	string b{ "string" };

	cout << addressof(b) << endl;


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:45:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;



int main()
{
	array<float, 10> a;

	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	
	cout << "===========================" << endl;
	string b{ "string" };

	cout << addressof(b) << endl;

	cout << "===========================" << endl;
	int c{};
	cout << addressof(c) << endl;

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:50:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test()
{
	int num;
	cout <<"넘주소:"<< & num << endl;
}

int main()
{


	int c{};
	cout << "c주소:" << &c << endl;
	array<float, 10> a;
	string b{ "string" };
	
	test();
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:50:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test(int ar)
{
	cout <<"넘주소:"<< &ar << endl;
}

int main()
{


	int c{};
	cout << "c주소:" << &c << endl;
	array<float, 10> a;
	string b{ "string" };
	
	test(c);

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:12:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test()
{
}

int main()
{
	int num;

	test();

	cout << "STACK" << endl;

	cout << "   -num" << addressof(num) << endl;

	cout << "CODE" << endl;

	cout << "   -main" << addressof(main) << endl;
	cout << "   -test" << addressof(test) << endl;
	cout << "   -save" << addressof(save) << endl;

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:16:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test()
{
}

int main()
{
	int num;

	test();
	long long val{ 0x7F'FF'FF'FF'FF'FF };

	cout << "사용할수있는 최대 메모리 의 한계" << val << endl;


	cout << "STACK" << endl;

	cout << "   -num" << addressof(num) << endl;

	cout << "CODE" << endl;

	cout << "   -main" << addressof(main) << endl;
	cout << "   -test" << addressof(test) << endl;
	cout << "   -save" << addressof(save) << endl;

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:22:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	

	cout << "DATA" << endl;
	cout<<"   -global num" << addressof(::num) << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:22:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	

	cout << "DATA" << endl;
	cout<<" -global num" << addressof(::num) << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:23:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	

	cout << "DATA" << endl;
	cout<<" -globalnum " << addressof(::num) << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:25:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "HEAP" << endl;
	int* ptr = new int();
	cout << " -heap " << addressof(ptr) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	
	cout << "DATA" << endl;
	cout<<" -globalnum " << addressof(::num) << endl;

	


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:26:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "HEAP" << endl;
	int* ptr = new int();
	cout << " -heap      " << addressof(ptr) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	
	cout << "DATA" << endl;
	cout<<" -globalnum   " << addressof(::num) << endl;

	


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:26:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "HEAP" << endl;
	int* ptr = new int();
	cout << " -heap      " << addressof(ptr) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	
	cout << "DATA" << endl;
	cout<<  "-gnum       " << addressof(::num) << endl;

	


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:05:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


int a[1'000'000];
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:06:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


int a[1'000'000]{ 1 };
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:10:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int a[1'000'000]; //  초기화 하지않은 전역데이터 (bss) --> 명령어로 대채가능
// int a[1'000'000]{ 1 }; // 초기화 한 전역 데이터
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:12:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int a[1'000'000]; //  초기화 하지않은 전역데이터 (bss) --> 명령어로 대채가능
// int a[1'000'000]{ 1 }; // 초기화 한 전역 데이터 -> 메몸리 image 를 실행파일에 붙임 컴파일 속도 느려짐
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}

======================================================================================



======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 1:09:20
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"

using namespace std;

//main.cpp의 모든 영문자를 대문자로 바꿔 main대문자.txt에 저장

int main() {

	//ZZZZZ

	save("main.cpp");
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:01:11
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};
void f()
{
	cout << "f 시작" << endl;

	Dog* p = new Dog;

	delete p;
	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:01:55
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};
void f()
{
	cout << "f 시작" << endl;

	shared_ptr<Dog> ptr = make_shared<Dog>();

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:02:06
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};
void f()
{
	cout << "f 시작" << endl;

	shared_ptr<Dog> ptr = make_shared<Dog>();

	ptr.reset();

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:05:41
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) :p{ p } {};
	~SmartPointer() {
		delete p;
	}


private:
	Dog* p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:06:02
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) : _p{ p } {};
	~SmartPointer() {
		delete _p;
	}


private:
	Dog* _p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:07:55
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) : _p{ p } {};

	~SmartPointer() 
	{
		delete _p;
	}


private:
	Dog* _p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	throw 1234;

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;

	try
	{
		f();
	}

	catch(...)
	{
		cout << "예외를 받았쩌용" << endl;
	}

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:08:07
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) : _p{ p } {};

	~SmartPointer() 
	{
		delete _p;
	}


private:
	Dog* _p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	throw 1234;

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;

	try
	{
		f();
	}

	catch(...)
	{
		cout << "예외를 받았쩌용" << endl;
	}

	save("main.cpp");

	cout << "main 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:37:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	~Dog() { cout << "dog 소멸" << endl; }
};

int main()
{
	unique_ptr<Dog> p(new Dog);





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:43:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	~Dog() { cout << "dog 소멸" << endl; }
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	unique_ptr<Dog[]> p(new Dog[10]);





	save("STL.cpp");
	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:44:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	~Dog() { cout << "dog 소멸" << endl; }
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	unique_ptr<Dog[]> p(new Dog[10]);





	save("STL.cpp");

	throw 1;



	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:50:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	Dog(int b) {
		a = b;
		cout << "dog 생성" << endl; 
	}
	~Dog() { cout << "dog 소멸" << endl; }

	int a = 10;
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	// 이 main() 은 문제없지만 불편하다. -> new 와 짝이 맞는 delete 가없다?

	unique_ptr<Dog[]> p = make_unique<Dog[]>(10);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:50:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	Dog(int b) {
		a = b;
		cout << "dog int 생성" << endl; 
	}
	~Dog() { cout << "dog 소멸" << endl; }

	int a = 10;
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	// 이 main() 은 문제없지만 불편하다. -> new 와 짝이 맞는 delete 가없다?

	unique_ptr<Dog[]> p = make_unique<Dog[]>(10);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:54:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t = isupper(t);
		}
		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:55:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t += 32;
		}

		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:55:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t += 32;
		}

		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:56:01
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t += 32;
		}

		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:07:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp"s,ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{"STL대문자.txt",ios::binary};
	char c;

	while (in.read(&c, sizeof(char)))
	{
		c=toupper(c);
		cout << c;

		out << c;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:17:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자.txt",ios::binary };


	transform(istreambuf_iterator<char>(in), {},
		ostreambuf_iterator<char>{out}, [](char c) 
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:18:00
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자2.txt",ios::binary };


	transform(istreambuf_iterator<char>(in), {},
		ostreambuf_iterator<char>{out}, [](char c) 
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:20:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자.txt",ios::binary };

	transform(istreambuf_iterator<char>(in), {},
		ostreambuf_iterator<char>{cout}, [](char c) 
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:21:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자.txt",ios::binary };

	transform(istream_iterator<char>(in), {},
		ostream_iterator<char>{cout}, [](char c)
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:25:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


int main()
{




	save("STL.cpp");

	

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:55:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.

int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}

int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), compare);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:02:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), [](const void* a, const void* b)
		{
			return (*(int*)a-*(int*)b);
		}
	);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:07:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int 함수(const void* a, const void* b) {
	return (*(int*)-*(int*)b);
}

int compare(const void* a, const void* b) {
	return (*(int*) - *(int*)b);
}



int main()
{
	array<int, 100> a;

	/*for (int& i : a)
	{
		i = uid(dre);
	}*/

	cout << typeid(compare).name() << endl;

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	/*qsort(a.data(), a.size(), sizeof(int), [](const void* a, const void* b)
		{
			return (*(int*)a-*(int*)b);
		}
	);





	for (int i : a)
	{
		print("{:8}", i);
	}*/


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:10:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	/*for (int& i : a)
	{
		i = uid(dre);
	}*/

	int (*함수)(const void*, const void*) = compare;

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), 함수);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:11:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	int (*함수)(const void*, const void*) = compare;

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), 함수);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 1:37:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	//int (*함수)(const void*, const void*) = compare;

	//qsort(a.data(), a.size(), sizeof(int), 함수);

	sort(a.begin(), a.end());


	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 1:39:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), [](int& n1, int&n2) {return n1>n2;});


	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 1:39:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), [](int& n1, int&n2) {return n1<n2;});


	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:00:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.
int cnt{};





int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), [](int a, int b){
			return a > b;
		});



	for (int i : a)
	{
		print("{:8}", i);
	}



	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:08:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.
int cnt{};

class Dog
{

public:


	bool operator()(int a, int b)
	{
		return a > b;
	}

	//friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
	//	return os;
	//}

};



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), Dog{});

	//람다의 장점 : 가독성이 대폭 상승 하였다.
	// 람다는 code segment 의 영역에 존재한다. 


	for (int i : a)
	{
		print("{:8}", i);
	}



	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:20:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.
int cnt{};

class Dog
{

public:


	bool operator()(int a, int b)
	{
		cnt++;
		return a > b;
	}

	void ShowResult() const
	{
		cout << endl;
		cout << cnt << "번 비교함수 호출 됨" << endl;
	}

private:

	static int cnt;

};

int Dog::cnt = 0;



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}


	
	Dog t;
	sort(a.begin(), a.end(),t);

	//람다의 장점 : 가독성이 대폭 상승 하였다.
	// 람다는 code segment 의 영역에 존재한다. 


	for (int i : a)
	{
		print("{:8}", i);
	}

	t.ShowResult();



	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:30:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{
	//함수를 define 한것임
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	//함수를 define  하고 호출한것
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	}();


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:30:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{
	//함수를 define 한것임
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	//함수를 define  하고 호출한것
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	}();

	//함수를 define  하고 호출한것
	[](int a,int b) {
		cout << "안녕 난 람다라고해! "<<a<<" " << b << endl;
	}(4,5);

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:32:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{

	//함수를 define  하고 호출한것
 	auto 람다 =[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	cout <<"람다의 정체" << typeid(람다).name() << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:37:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{

	//함수를 define  하고 호출한것
 	auto 람다1 =[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	auto 람다2 = []() {
		cout << "안녕 난 람다라고해! " << endl;
		};
	cout << "람다1의 정체" << typeid(람다1).name() << endl;
	cout << "람다2의 정체" << typeid(람다2).name() << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:38:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;


auto 람다1 = []() {
	cout << "안녕 난 람다라고해! " << endl;
	};

auto 람다2 = []() {
	cout << "안녕 난 람다라고해! " << endl;
	};

int main()
{

	
	cout << "람다1의 정체" << typeid(람다1).name() << endl;
	cout << "람다2의 정체" << typeid(람다2).name() << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:51:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;

void f(int(*x)(int ,int))
{
	cout <<x(3,5) <<endl;
}

int x(int a, int b)
{
	return a * b;
}

int main()
{
	
	f(x);
	
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:54:30
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;

void f(int(*x)(int ,int))
{
	cout <<x(3,5) <<endl;
}

int x(int a, int b)
{
	return a * b;
}

int main()
{

	f([](int, int) ->int {return 333; });
	
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:58:40
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
// --> 모든 호출가능 타입을 대표하는 클래스 -> function
// 
//-------------------------------------------------------------------------------------------------------


#include <functional>
#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;

void f(function<int(int,int)>x)
{
	cout <<x(3,5) <<endl;
}

int x(int a, int b)
{
	return a * b;
}

int main()
{

	f([](int, int) ->int {return 333; });
	f(x);

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 3:10:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{

	size_t len{};
	unique_ptr<char[]> p{};

public:

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}




	char *ptr;
};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	//String t = s;
	cout << s << endl;
	//cout << t << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 1:41:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{


public:

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	String(const String& other)
	{
		len = other.len;
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}


	
	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	
	String v = s;

	cout << s << endl;
	cout << v << endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 1:52:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{


public:

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	String(const String& other)
	{
		len = other.len;
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}



	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	
	String v = s;

	cout << s << endl;
	cout << v << endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 1:53:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{


public:
	String() = default;

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	String(const String& other)
	{
		len = other.len;
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}

	


	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	
	String v = s;

	cout << s << endl;
	cout << v << endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:14:17
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"







int main()
{

	String s{ "STL 공부를 위한 클래스" };
	String t;
	t = s;
	std::cout << s << std::endl;
	std::cout << t << std::endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:14:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"







int main()
{

	String s{ "STL 공부를 위한 클래스" };
	String t;
	t = s;
	std::cout << s << std::endl;
	std::cout << t << std::endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:15:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"







int main()
{

	String s{ "STL 공부를 위한 클래스" };
	String t;
	t = s;
	std::cout << s << std::endl;
	std::cout << t << std::endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:18:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:18:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:18:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:19:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:22:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:22:59
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:23:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:24:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 2:24:09
=============================================== 

#pragma once
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	String(const String& other);

	static int test(const String& a, const String& b);


	String& operator=(const String& rhs);


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 2:24:09
=============================================== 

#include "Mystring.h"
size_t String::uid{};

String::String():id(uid++)
{
	
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	
}

String::~String()
{
	cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}

String::String(const char* s):id(uid++)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	cout << "[" << id << "] - 생성자 생성,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}

String::String(const String& other):id(uid++)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	cout << "[" << id << "] - 복사 생성,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}

int String::test(const String& a, const String& b)
{
	return a.len < b.len;
}



String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:55:04
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;


//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 2:55:04
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 2:55:04
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:56:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;


//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"1" ,"333","555","777777", "99999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 2:56:29
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 2:56:29
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:03:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281329" ,"332342343","553243242345","7772343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetPtr() < b.GetPtr();
		});


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:03:32
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:03:32
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:06:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281329" ,"332342343","553243242345","7772343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:06:52
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:06:52
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:07:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281329" ,"332342343","553243242345","7772343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:07:08
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:07:08
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:07:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281435329" ,"33233455142343","553123279243242345","7778972343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:07:22
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:07:22
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:09:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281435329" ,"33233455142343","553123279243242345","7778972343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	관찰 = true;
	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}
	관찰 = false;

	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:09:31
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:09:31
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:23:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// Container 에 대해 공부 해보자~
// STL : Container [자료구조]               / Algorithm[알고리즘] 
// 1.Sequence Container                       1.Non-modifying Alogrithm
// 2.Associative Container					  2. Modifying
// 3.Unordered Container                      3. Sort
// Adaptor => Stack,Queue,FlatSet,FlatMap     numeric,
// 
// find -> 1. 첫원소? (being) 2. 다음원소? ++ 3. 마지막? (end) 로 통일 => iterator [디자인 패턴]
// OCP =>  자료구조가 추가되더라도 똑같이 알고리즘이 작동?
//  Sequence => 1. array[T,N] 2. vector<T> 3. deque<T> (덱)[양향확장] 4.forward_list<T> 5.list<T>   
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
using namespace std;

int main()
{


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:36:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a;



	//iterator 의 기본동작은 다음과같다
	array<int, 10>::iterator p = a.begin();
	p.operator++();
	p++;
	array<int, 10>::iterator e = a.end();




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:38:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a;



	//iterator 의 기본동작은 다음과같다
	for (array<int, 10>::iterator p = a.begin(); p != a.end(); p.operator++())
	{
		cout << p.operator*() << endl; 
	};




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:38:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a{ 1,2,3,4,5,6,7,8,9 };



	//iterator 의 기본동작은 다음과같다
	for (array<int, 10>::iterator p = a.begin(); p != a.end(); p.operator++())
	{
		cout << p.operator*() << endl; 
	};




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:38:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};



	//iterator 의 기본동작은 다음과같다
	for (array<int, 10>::iterator p = a.begin(); p != a.end(); p.operator++())
	{
		cout << p.operator*() << endl; 
	};




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:47:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	//array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};
	/*list<int> a{ 1,2,3,4,5,6,7,8,9 };*/
	set<int> a{ 1,6,7,4,2,3,2,1,2 };


	//iterator 의 기본동작은 다음과같다
	for(auto p = a.begin(); p != a.end(); ++p)
	{
		cout << *p << endl; 
	};

	for (auto& i : a)
	{
		cout << i << endl;
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:47:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	//array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};
	/*list<int> a{ 1,2,3,4,5,6,7,8,9 };*/
	set<int> a{ 1,6,7,4,2,3,2,1,2 };


	//iterator 의 기본동작은 다음과같다
	for(auto p = a.begin(); p != a.end(); ++p)
	{
		cout << *p << endl; 
	};

	//range based for -> range for 
	for (auto& i : a)
	{
		cout << i << endl;
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:50:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	//array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};
	/*list<int> a{ 1,2,3,4,5,6,7,8,9 };*/
	set<int> a{ 1,6,7,4,2,3,2,1,2 };


	//iterator 의 기본동작은 다음과같다
	for(auto p = a.begin(); p != a.end(); ++p)
	{
		cout << *p << endl; 
	};

	//range based for -> range for 
	for (auto& i : a) 
	{
		cout << i << endl;
	}
	//==> 컴파일러가 장난쳐줌
	// syntatic sugar

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 3:02:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};


	try
	{
		a.at(-20);
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;
	}




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:38:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:40:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[i];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:42:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[i];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}


	sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});


	

	save("STL.cpp");
	save("Mystring.cpp");

}




=============================================== 
Mystring.cpp 2024-04-11 목요일 오후 1:42:05
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


//입출력함수 오버로딩
std::ostream& operator<<(std::ostream& os, const String& s)
{
	for (size_t i = 0; i < s.len; ++i)
	{
		os << s.p.get()[i];
	}

	return os;
}

std::istream& operator>>(istream& is, String& other)
{

	std::string str;
	is >> str;



	other.len = str.size();
	other.p = make_unique<char[]>(other.len);
	memcpy(other.p.get(), str.data(), other.len);

	return is;
	//std::string str;
	//// Read string using >> operator
	//is >> str;

	//// Allocate memory for the string in String object
	//other.p.reset(new char[str.length() + 1]);

	//// Copy string content to the allocated memory
	//memcpy(other.p.get(), str.c_str(), str.length() + 1);

	//// Update length
	//other.len = str.length();

	//return is;


}

=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:48:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{


	vector<int> v(1'0000'0000,3);

	for (int num : v | views::drop(v.size()-100))
	{
		cout << num << " ";
	}

	cout << endl;
	cout << sizeof(v) << endl;




	save("STL.cpp");
	//save("Mystring.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:01:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");



	//for (int num : v | views::drop(v.size()-1))
	//{
	//	cout << num << " ";
	//}

	//cout << endl;
	//cout << sizeof(v) << endl;




	save("STL.cpp");
	//save("Mystring.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:03:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");



	//for (int num : v | views::drop(v.size()-1))
	//{
	//	cout << num << " ";
	//}

	//cout << endl;
	//cout << sizeof(v) << endl;




	save("STL.cpp");
	//save("Mystring.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:15:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");

	cout << endl<< "원소추가------------------" << endl;
	v.push_back("4월");
;

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:16:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");
	cout << v.capacity() << endl;

	cout << endl<< "원소추가------------------" << endl;
	v.push_back("4월");
;	cout << v.capacity() << endl;

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:53:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;
	v.reserve(10); //공간을 미리 마련하고 사용하자 - 새 메모리를 확보하기 위한 노력이 필요없음

	v.push_back("2024년");


	cout << endl<< "원소추가------------------" << endl;
	v.push_back("4월");

	cout << endl << "원소추가------------------" << endl;
	v.push_back("11일");

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 3:02:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;
	v.reserve(10); //공간을 미리 마련하고 사용하자 - 새 메모리를 확보하기 위한 노력이 필요없음

	v.emplace_back("2024년");
	// push_back 의 시간 복잡도 o(1) 이다 .[ 단 이사가지않는다면  ] (armotized constant time)




	cout << endl<< "원소추가------------------" << endl;
	v.emplace_back("4월");

	cout << endl << "원소추가------------------" << endl;
	v.emplace_back("11일");

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 1:35:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	vector<String> v;

	v.push_back("벡터입니다.");

	cout << endl << endl;

	v.push_back("벡터는 dynamic array 입니다.");


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:01:13
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	vector<String> v;

	v.reserve(20);

	v.emplace_back("벡터입니다.");

	cout << endl << endl;

	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	cout << endl << endl;
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:03:59
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:05:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(5);

	for (int i = 0; i < 5; ++i)
	{
		v.push_back(1);
	}


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:05:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(5);

	for (int i = 0; i < 5; ++i)
	{
		v.push_back(123);
	}


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:06:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(123);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	for (int i = 0; i < 123; ++i)
	{
		v.push_back(1);
	}
	v.push_back(1);
	cout << endl;


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:07:04
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(123);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	for (int i = 0; i < 123; ++i)
	{
		v.push_back(1);
	}
	cout << endl;


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	v.push_back(1);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:07:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(123);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	for (int i = 0; i < 123; ++i)
	{
		v.push_back(1);
	}
	cout << endl;


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	v.push_back(1);

	cout << endl;

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:17:27
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	cout << "vector<int> 최대 몇개?" << v.max_size() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:18:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	cout << "vector<int> 최대 몇개?" << v.max_size() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:18:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	cout << "vector<int> 최대 몇개?" << v.max_size() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:22:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };

	for (int num : {1, 3, 5, 7, 8})
	{
		cout << num << endl;
	}



	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:23:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };




	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:23:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };




	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:23:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };




	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:25:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };

	remove(v.begin(), v.end(), 3);

	


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:26:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	remove(v.begin(), v.end(), 3);

	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:26:34
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:28:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:28:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:28:57
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:35
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:30:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 6);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:34:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:35:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,3,3,3,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:35:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,3,3,4,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:36:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,3,3,4,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:36:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,4,4,4,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:37:01
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,4,4,4,3,3};

	auto it =remove(v.begin(), v.end(), 4);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:39:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 4);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:41:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 4);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:41:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 4);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	//for (auto& i : v)
	//{
	//	cout << i << endl;
	//}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	//for (auto& i : v)
	//{
	//	cout << i << endl;
	//}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:57
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:43:13
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:43:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,3,2,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:44:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:45:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					   // = { 1,2,4,5,2,4,2,3,4
	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:46:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					
	v.erase(remove(v.begin(), v.end(), 3),v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:47:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					
	v.erase(remove(v.begin(), v.end(), 3),v.end());

	erase(v, 3);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:47:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					
	/*v.erase(remove(v.begin(), v.end(), 3),v.end());*/

	erase(v, 3);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:53:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v;

	v.reserve(100);

	iota(v.begin(), v.end(), 1);
	
	for (int num : v)
	{
		print("{:8}",num );
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:58:40
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v(100);

	iota(v.begin(), v.end(), 1);
	

	auto it =remove_if(v.begin(), v.end(), [](const int& n1)
		{
			return (n1 % 2 != 0);
		});
	
	
	v.erase(it, v.end());

	for (int num : v)
	{
		print("{:8}", num);
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:01:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v(100);

	iota(v.begin(), v.end(), 1);
	

	/*auto it =remove_if(v.begin(), v.end(), [](const int& n1)
		{
			return (n1 % 2 != 0);
		});*/

	erase_if(v, [](const int& n1) {
		return n1&1;
		});

	for (int num : v)
	{
		print("{:8}", num);
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:14:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	char ch = 'a';

	cout << (int)ch;

	

	

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:21:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	std::map<char, int> Map;

	for (int i = 'a'; i < 'z'; ++i)
	{
		Map[i] = 0;
	}

	ifstream in{ "STL.cpp" };

	char ch;

	while (in >> ch)
	{
		if (ch >= 'a' && ch <= 'z')
		{
			Map[ch] += 1;
		}
	}
	
	
	for (auto& pair : Map)
	{
		cout << "문자:"<<pair.first << " , 갯수:" << pair.second << endl;
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:21:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	std::map<char, int> Map;


	ifstream in{ "STL.cpp" };

	char ch;

	while (in >> ch)
	{
		if (ch >= 'a' && ch <= 'z')
		{
			Map[ch] += 1;
		}
	}
	
	
	for (auto& pair : Map)
	{
		cout << "문자:"<<pair.first << " , 갯수:" << pair.second << endl;
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 1:42:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	array<int, 26> alphaNum{};


	ifstream in{ "STL.cpp" };

	if (not in)
	{
		return 0;
	}

	char c;
	while (in >> c)
	{
		if (islower(c))
		{
			alphaNum[c - 'a']++;
		}
	}

	for (int i = 0; i < 26; ++i)
	{
		cout << static_cast<char>('a' + i) << "-" << alphaNum[i] << endl;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/*std::map<char, int> Map;

	

	ifstream in{ "STL.cpp" };

	char ch;

	while (in >> ch)
	{
		if (ch >= 'a' && ch <= 'z')
		{
			Map[ch] += 1;
		}
	}
	
	
	for (auto& pair : Map)
	{
		cout << "문자:"<<pair.first << " , 갯수:" << pair.second << endl;
	}*/

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 1:55:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;



//[문제] 
// 키보드에서 입력한 단어를 오름차순으로 정렬후 출력하라.



int main()
{

	vector<int>v{ 1,2,3,4,5 };

	erase(v, 3);

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:12:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	erase(v, "3");

	//auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	//	return s.GetPtr() == "안녕";
	//	});

	//v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:12:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	erase(v, "3");

	//auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	//	return s.GetPtr() == "안녕";
	//	});

	//v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:14:04
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	//erase(v, "3");

	auto it = remove_if(v.begin(), v.end(), [](const String& s) {
		return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
		});

	v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:14:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	//erase(v, "3");

	auto it = remove_if(v.begin(), v.end(), [](const String& s) {
		return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
		});

	v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:15:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.
	관찰 = true;
	erase(v, "3");
	관찰 = false;
	////auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	////	return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
	////	});

	////v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:15:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.
	관찰 = true;
	erase(v, "3");
	관찰 = false;
	////auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	////	return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
	////	});

	////v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "2");
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	cout << *it << endl;
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	cout << *it << endl;
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:21:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","4","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:30:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// erase , insert - O(N)
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
#include <list>
using namespace std;




int main()
{


	list<String>v{ "1","22","4444","55555"};
	

	//관찰 = true;
	auto it = find(v.begin(), v.end(), "4");
	//auto p = v.begin();
	//++p;
	//++p;

	관찰 = true;
	v.emplace(it, "3");
	관찰 = false;

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:44:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:44:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:45:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3,4 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}

	cout << endl;
	d.push_back(5);
	cout << endl;

	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:45:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3,4 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}

	cout << endl;
	d.push_back(5);
	cout << endl;

	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:47:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3,4 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << "--" << &d[i] << endl;
	}

	cout << endl;
	d.push_back(5);
	cout << endl;

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i]<<"--" << &d[i] << endl;
	}

	d.push_front(0);

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << "--" << &d[i] << endl;
	}

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 1:53:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"

using namespace std;






int main()
{
	list<String> v;
	관찰 = true;
	
	v.emplace_back("333");
	v.emplace_front("1");
	v.emplace(++(v.begin()), "22");

	for (auto& i : v) {
		cout << i << endl;
	}


	관찰 = false;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:11:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	String s;

	while (in >> s) {
		v.emplace_back(s);
	}

	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:11:59
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
		v = { istream_iterator<String>{in},{} };

	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:14:17
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };

	for (auto& i : v) {
		cout << i << endl;
	}

	//길이오름차순으로 정렬하라.

	//sort(v.begin(), v.end(), [](const auto& s1, const auto& s2) {
	//	return s1.GetLen() < s2.GetLen();
	//	});

	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:23:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.

	/*sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});*/

	cout << *v.end() << endl;

	/*for (auto& i : v) {
		cout << i << endl;
	}*/

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:24:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	//관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.

	/*sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});*/

	cout << *v.begin() << endl;

	/*for (auto& i : v) {
		cout << i << endl;
	}*/

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:24:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	//관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.

	/*sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});*/

	cout << *v.end() << endl;

	/*for (auto& i : v) {
		cout << i << endl;
	}*/

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:25:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	//관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.

	/*sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});*/

	cout << *(--v.end()) << endl;

	/*for (auto& i : v) {
		cout << i << endl;
	}*/

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:25:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	//관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.

	/*sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});*/



	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:26:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.
	//관찰 = true;

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.

	/*sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});*/

	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});


	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:26:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.

	/*sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});*/
	관찰 = true;
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});


	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:27:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	vector<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.


	관찰 = true;
	//v.sort([](const String& s1, const String& s2) {
	//	return s1.GetLen() < s2.GetLen();
	//	});
	sort(v.begin(), v.end(), [](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});

	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:29:57
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.


	관찰 = true;
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});

	v.reverse();

	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:30:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.


	관찰 = true;
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});
	
	//원소의 순서를 거꾸로 저장
	v.reverse();

	for (auto& i : v) {
		cout << i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:33:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.


	관찰 = true;
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});
	
	//원소의 순서를 거꾸로 저장
	v.reverse();


	//[문제] 컨테이너를 역순으로 출력해봐라.


	for (auto i = v.end(); i != v.begin(); --i) {
		cout << *i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:34:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;






int main()
{
	list<String> v;
	/*v.reserve(500);*/

	//[문제] 파일 " String.cpp 를 읽어 컨테이너에 저장하라.

	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	
	v = { istream_iterator<String>{in},{} };


	//길이오름차순으로 정렬하라.


	관찰 = true;
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});
	
	//원소의 순서를 거꾸로 저장
	v.reverse();


	//[문제] 컨테이너를 역순으로 출력해봐라.


	for (auto i = v.rbegin(); i != v.rend(); ++i) {
		cout << *i << endl;
	}

	관찰 = false;





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:45:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;





int main()
{
	list<String> v;
	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	v = { istream_iterator<String>{in},{} };
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});
	
	//[문제] 컨테이너에서 길이가 5인 원소만 화면에 출력하라.
	find_if(v.begin(), v.end(), [](const String& s) {
		return s.GetLen() == 5;
		});


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:45:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;





int main()
{
	list<String> v;
	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	v = { istream_iterator<String>{in},{} };
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});
	
	//[문제] 컨테이너에서 길이가 5인 원소만 화면에 출력하라.
	auto it =find_if(v.begin(), v.end(), [](const String& s) {
		return s.GetLen() == 5;
		});

	cout << *it << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:47:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;





int main()
{
	list<String> v;
	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	v = { istream_iterator<String>{in},{} };
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});
	
	//[문제] 컨테이너에서 길이가 5인 원소만 화면에 출력하라.

	//auto it =find_if(v.begin(), v.end(), [](const String& s) {
	//	return s.GetLen() == 5;
	//	});

	//cout << *it << endl;


	for (auto iter = v.begin(); iter != v.end(); ++iter) {
		if (iter->GetLen() == 5) {
			cout << *iter << endl;
		}
	}
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-23 화요일 오후 2:48:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 23일 목요일  (8 주 1)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱-> 벡터와 리스트의 짬뽕
// push_back , push_front => o(1) 알고리즘
// 리스트의 단점: 메모리를 많이먹는다 ,  순회속도가 느리다.
// 
// 
// //Sequence Container 
// -array  와 vector 의 공통점: 랜덤엑세스 가 지원됨 
// -deque 
// -list
// -forward_list  => read /write access 가 둘다가능함.
// -vector o(1) -> push_back , deque o(1) -> pushback + pushfront   // insert delete 는 느리다.
// -list 한테 편한동작 -> 대부분의 동작 (pushback + insert , delete )
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
#include <list>
#include <array>
#include "Mystring.h"
#include "save.h"
#include <fstream>
using namespace std;





int main()
{
	list<String> v;
	ifstream in{ "Mystring.cpp",ios::binary};

	if (not in) {
		return -1;
	}

	v = { istream_iterator<String>{in},{} };
	v.sort([](const String& s1, const String& s2) {
		return s1.GetLen() < s2.GetLen();
		});
	
	//[문제] 컨테이너에서 길이가 5인 원소만 화면에 출력하라.

	//auto it =find_if(v.begin(), v.end(), [](const String& s) {
	//	return s.GetLen() == 5;
	//	});

	//cout << *it << endl;


	for (auto iter = v.begin(); iter != v.end(); ++iter) {
		if (iter->GetLen() == 5) {
			cout << *iter << endl;
		}

		if (iter->GetLen() > 5) {
			break;
		}
	}
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-30 화요일 오후 2:45:40
=============================================== 

//-----------------------------------------------------------------------------
// 2024 STL 중간시험
// 
// Visual Studio 버전 17.9.0 이상 
// Release / x64
// 프로젝트 속성 - C++ 언어 표준 - 최신 C++ 초안의 기능(/std:c++latest)
//-----------------------------------------------------------------------------
// 답지 작성 방법
// - 각 문제를 해결하는 데 필요한 코드만 적는다.
// - 화면에 출력을 요구하는 문제는 출력된 내용을 답지에 적는다.
// - 헤더 파일을 적을 필요는 없다.
//-----------------------------------------------------------------------------

#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include "Mystring.h"
using namespace std;




int main()
{
	list<String> cont{"1","22","333","4444","55555"};
	list<String> cont2{ "1","22","a","bb","333","4444","55555" };

	//cont.merge(cont2);

	//for (auto i : cont) {
	//	cout << i << endl;
	//}


	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-04-30 화요일 오후 3:07:21
=============================================== 

//-----------------------------------------------------------------------------
// 2024 STL 중간시험
// 
// Visual Studio 버전 17.9.0 이상 
// Release / x64
// 프로젝트 속성 - C++ 언어 표준 - 최신 C++ 초안의 기능(/std:c++latest)
//-----------------------------------------------------------------------------
// 답지 작성 방법
// - 각 문제를 해결하는 데 필요한 코드만 적는다.
// - 화면에 출력을 요구하는 문제는 출력된 내용을 답지에 적는다.
// - 헤더 파일을 적을 필요는 없다.
//-----------------------------------------------------------------------------

#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include "Mystring.h"
using namespace std;





int main()
{
	
	//[문제] 파일 "STL.CPP" 의 단어를 읽어 정렬한후 출력하라.

	String ptr;
	ifstream in("STL.cpp");

	list<String> cont{ istream_iterator<String> {in},{} };

	cont.sort();

	for (const auto& s : cont) {
		cout << s << endl;
	}

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-04-30 화요일 오후 3:09:56
=============================================== 

//-----------------------------------------------------------------------------
// 2024 STL 중간시험
// 
// Visual Studio 버전 17.9.0 이상 
// Release / x64
// 프로젝트 속성 - C++ 언어 표준 - 최신 C++ 초안의 기능(/std:c++latest)
//-----------------------------------------------------------------------------
// 답지 작성 방법
// - 각 문제를 해결하는 데 필요한 코드만 적는다.
// - 화면에 출력을 요구하는 문제는 출력된 내용을 답지에 적는다.
// - 헤더 파일을 적을 필요는 없다.
//-----------------------------------------------------------------------------

#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include "Mystring.h"
using namespace std;

// 중복된것을 제거 => 개수 26 개면 +1 
// allof 함수
int main()
{
	
	//[문제] 파일 "STL.CPP" 의 단어를 읽어 정렬한후 출력하라.

	String ptr;
	ifstream in("STL.cpp");

	list<String> cont{ istream_iterator<String> {in},{} };

	cont.sort();
	cont.unique();

	for (const auto& s : cont) {
		cout << s << endl;
	}

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 1:28:59
=============================================== 

//-----------------------------------------------------------------------------
// 2024 STL 중간시험
// 
// Visual Studio 버전 17.9.0 이상 
// Release / x64
// 프로젝트 속성 - C++ 언어 표준 - 최신 C++ 초안의 기능(/std:c++latest)
//-----------------------------------------------------------------------------
// 답지 작성 방법
// - 각 문제를 해결하는 데 필요한 코드만 적는다.
// - 화면에 출력을 요구하는 문제는 출력된 내용을 답지에 적는다.
// - 헤더 파일을 적을 필요는 없다.
//-----------------------------------------------------------------------------

#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include "Mystring.h"
using namespace std;

// 중복된것을 제거 => 개수 26 개면 +1 
// allof 함수
int main()
{
	
	//[문제] 파일 "STL.CPP" 의 단어를 읽어 정렬한후 출력하라.

	String ptr;
	ifstream in("STL.cpp");

	list<String> cont{ istream_iterator<String> {in},{} };

	cont.sort();
	cont.unique();

	for (const auto& s : cont) {
		cout << s << endl;
	}

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 1:29:53
=============================================== 

//-----------------------------------------------------------------------------
// 2024 STL 중간시험
// 
// Visual Studio 버전 17.9.0 이상 
// Release / x64
// 프로젝트 속성 - C++ 언어 표준 - 최신 C++ 초안의 기능(/std:c++latest)
//-----------------------------------------------------------------------------
// 답지 작성 방법
// - 각 문제를 해결하는 데 필요한 코드만 적는다.
// - 화면에 출력을 요구하는 문제는 출력된 내용을 답지에 적는다.
// - 헤더 파일을 적을 필요는 없다.
//-----------------------------------------------------------------------------

#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include "Mystring.h"
using namespace std;

// 중복된것을 제거 => 개수 26 개면 +1 
// allof 함수,


int main()
{
	
	//[문제] 파일 "STL.CPP" 의 단어를 읽어 정렬한후 출력하라.


	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 1:35:19
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2
// 
// list - 컨테이너는 자기가 잘 할 수있는 동작을 멤버함수로 제공한다.
// 동일한 알고리즘 함수와 멤버함수가 있다면 멤버함수를 사용한다.
// ex )
// remove 는 전역알고리즘 함수 / list 의 멤버함수도있음.
// sort 는 전역알고리즘 함수 / list 의 멤버 함수로 도 있음 .
// 멤버함수를 사용한다.
//-----------------------------------------------------------------------------
// 답지 작성 방법
// - 각 문제를 해결하는 데 필요한 코드만 적는다.
// - 화면에 출력을 요구하는 문제는 출력된 내용을 답지에 적는다.
// - 헤더 파일을 적을 필요는 없다.
//-----------------------------------------------------------------------------

#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include "Mystring.h"
using namespace std;

// 중복된것을 제거 => 개수 26 개면 +1 
// allof 함수
int main()
{
	
	//[문제] 파일 "STL.CPP" 의 단어를 읽어 정렬한후 출력하라.

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 1:49:26
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2
// 
// list - 컨테이너는 자기가 잘 할 수있는 동작을 멤버함수로 제공한다.
// 동일한 알고리즘 함수와 멤버함수가 있다면 멤버함수를 사용한다.
// ex )
// remove 는 전역알고리즘 함수 / list 의 멤버함수도있음.
// sort 는 전역알고리즘 함수 / list 의 멤버 함수로 도 있음 .
// 멤버함수를 사용한다.
//-----------------------------------------------------------------------------
// 답지 작성 방법
// - 각 문제를 해결하는 데 필요한 코드만 적는다.
// - 화면에 출력을 요구하는 문제는 출력된 내용을 답지에 적는다.
// - 헤더 파일을 적을 필요는 없다.
// 
// -  forward list ( list 에 비해 더 공간을 효율적으로 사용함 왜? 단일연결리스트이므로  
//    it is intended that forward_list have zero space or time overhead realative to a hand - written c - style singly linked list
//	  Features that would conflict with that goal have benn omitted.
//	  사용법이 쉽지않다 , 사용하는 사람이 거의없다 .
//	  아무리 잘 코딩해도 이것보다 잘할수없다.
//-----------------------------------------------------------------------------

#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
using namespace std;


int main()
{
	
	forward_list<int> v;

	

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:08:15
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2
// 
// list - 컨테이너는 자기가 잘 할 수있는 동작을 멤버함수로 제공한다.
// 동일한 알고리즘 함수와 멤버함수가 있다면 멤버함수를 사용한다.
// ex )
// remove 는 전역알고리즘 함수 / list 의 멤버함수도있음.
// sort 는 전역알고리즘 함수 / list 의 멤버 함수로 도 있음 .
// 멤버함수를 사용한다.
//-----------------------------------------------------------------------------
//  Sequence -  [[array ,vector] -> contiguous _iterator ,deque] -> random_acces_iterator 
//   [list ,forwardlist] 
//   
//    span  -> contriguous memory 를 가진 컨테이너를 대표하는 클래스
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>

using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


int main()
{
	
	int a[10] = { 1,3,5,7,9,2,4,6,8,10 };

	//연속적인 메모리에만 사용가능 , span 을 통해 STL 자료구조 마냥 사용가능 
	span<int> s{ a };

	sort(s.begin(), s.end());
	

	for (auto i = s.begin(); i < s.end(); ++i) {
		cout << *i << endl;
	}


	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:29:28
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


int main()
{
	//출력반복자의 동작을 알아본다.

	ostream_iterator<char> p{ cout };

	cout <<"출력반복자의 크기"<< sizeof(p) << endl;
	cout << "출력반복자의 타입" << typeid(p).name() << endl;

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:32:42
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


int main()
{
	//출력반복자의 동작을 알아본다.


	ostream_iterator<char> p{ cout };
	*p = 'a';
	++p;
	*p = 'b';
	++p;
	*p = 'c';

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:37:17
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


int main()
{
	//출력반복자의 동작을 알아본다.


	ostream_iterator<char> p{ cout };
	
	p = 'a';
	p = 'b';
	p = 'c';
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:42:55
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view

void f(auto it)
{
	cout << typeid(it).name() << endl;
}

int main()
{

	vector<int> v;

	f(v.begin());

	// 반복자는 6가지 종류로 구분된다.
	// 함수 f 는 반복자를 인자로 받아 어떤 종류인지 출력한다.
	// f 를 코딩하라.



	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:44:34
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view

void f(auto it)
{
	cout << typeid(it).name() << endl;
}

int main()
{

	vector<int> v;

	f(v.begin());

	ostream_iterator<char> p{ cout };

	f(p);
	// 반복자는 6가지 종류로 구분된다.
	// 함수 f 는 반복자를 인자로 받아 어떤 종류인지 출력한다.
	// f 를 코딩하라.



	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:45:44
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view

template<typename T>
void f(T it)
{
	cout << typeid(it).name() << endl;
}

int main()
{

	vector<int> v;

	f(v.begin());

	ostream_iterator<char> p{ cout };

	f(p);
	// 반복자는 6가지 종류로 구분된다.
	// 함수 f 는 반복자를 인자로 받아 어떤 종류인지 출력한다.
	// f 를 코딩하라.



	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:45:59
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view

template<typename T>
void f(const T it)
{
	cout << typeid(it).name() << endl;
}

int main()
{

	vector<int> v;

	f(v.begin());

	ostream_iterator<char> p{ cout };

	f(p);
	// 반복자는 6가지 종류로 구분된다.
	// 함수 f 는 반복자를 인자로 받아 어떤 종류인지 출력한다.
	// f 를 코딩하라.



	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 2:56:45
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


template<typename T>
void f(const T it)
{
	cout << typeid(T::iterator_category).name() << endl;
}

int main()
{
	{
		vector<String> v;
		f(v.begin());
	}
	{
		ostream_iterator<char> v{ cout };
		f(v);
	}
	{
		istream_iterator<char>  v{ cin };
		f(v);
	}

	{
		list<String>  v;
		f(v.begin());
	}

	{
		deque<String>  v;
		f(v.begin());
	}

	{
		forward_list<String>  v;
		f(v.begin());
	}


	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 3:08:01
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


template<typename T>
void f(const T it)
{
	cout << typeid(T::iterator_category).name() << endl;
}


int main()
{
	
	//우리가 만든클래스 String 은 contingus 메모리를 관리한다.
	// 다음 코드가 실행되게 하라.
	
	String s{ "0123456" };
	cout << s << endl;

	//for (char a: s) {
	//	cout << a << " ";
	//}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-02 목요일 오후 3:41:22
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


template<typename T>
void f(const T it)
{
	cout << typeid(T::iterator_category).name() << endl;
}


int main()
{
	
	//우리가 만든클래스 String 은 contingus 메모리를 관리한다.
	// 다음 코드가 실행되게 하라.

	String s("12345");

	cout << s.begin() << endl;

	//String s{ "0123456" };
	//cout << s << endl;

	//for (char a: s) {
	//	cout << a << " ";
	//}
	//cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 1:23:16
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 2일 목 9주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


template<typename T>
void f(const T it)
{
	cout << typeid(T::iterator_category).name() << endl;
}


int main()
{
	
	//우리가 만든클래스 String 은 contingus 메모리를 관리한다.
	// 다음 코드가 실행되게 하라.

	const char* ptr = "12341243";


	String s{ "0123456" };
	cout << s << endl;

	for (char a: s) {
		cout << a << " ";
	}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 1:44:41
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


template<typename T>
void f(const T it)
{
	// SFINE 
	cout << typeid(T::iterator_category).name() << endl;
}


int main()
{
	


	int* ptr; //random_excess_iteartor 한종류 이다
	/*f(ptr);*/

	
	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 2:02:34
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;

// T[N] , vector[N] => SPAN
// CHAR* p ={"   "} , char name[40] , string s{"name"} => string_view


template<typename T>
void f(const T it)
{
	// SFINE 
	/*cout << typeid(T::iterator_category).name() << endl;*/

	//반복자의 종류를 판단하는 표준 문장
	cout << typeid(iterator_traits<T>::iterator_category).name() << endl;
	cout << typeid(T::iterator_concept).name() << endl;
};



int main()
{

	// c++ 17 이후에 벡터의 반복자가 contigous 하다 라는 대답을 원한다면 ?

	f(vector<int>::iterator{});



	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 2:24:17
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;




int main()
{

	String s{ "1357924680" };

	sort(s.begin(), s.end());

	for (char c : s) {             // range -based for loop == for each for
		cout << c << " ";
	}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 2:29:40
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;




int main()
{

	String s{ "1357924680" };

	for (auto i = s.rbegin(); i != s.rend(); --i)
	{
		cout << *i << " ";
	}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 2:29:46
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;




int main()
{

	String s{ "1357924680" };

	for (auto i = s.rbegin(); i != s.rend(); --i)
	{
		cout << *i << " ";
	}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 2:29:48
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;




int main()
{

	String s{ "1357924680" };

	for (auto i = s.rbegin(); i != s.rend(); --i)
	{
		cout << *i << " ";
	}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 2:33:40
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
using namespace std;




int main()
{

	String s{ "1357924680" };

	span<char> ss(s.begin(), s.end());

	for (auto i = ss.rbegin(); i != ss.rend(); ++i)
	{
		cout << *i << " ";
	}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 2:56:57
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;




int main()
{

	String s{ "13579246890" };

	for (auto i = s.rbegin(); i != s.rend(); ++i)
	{
		cout << i.operator*() << " ";
	}
	cout << endl;

	
	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-05-07 화요일 오후 3:09:55
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 7일 목 10주 1일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;




int main()
{

	string s{ "13579246890" };

	//s 의 반복자 - random_acess_iterator_tag 가 되는게 좋다
	// 	
	save("STL.cpp");

	

}

=============================================== 
STL.cpp 2024-05-09 목요일 오후 1:47:21
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
// 6월 6일 강의 예정
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

//string => contigous 메모리이며 sequence container 이다.
// string 이 STL containter 가되려면 , iterator 를 제공해야함.
// string::value_type 
template <typename T>
void f(T iter)
{
	cout << typeid(iterator_traits<T>::iterator_category).name() << endl;
}

//cout << typeid(iterator_traits<string>::iterator_category).name() << endl;
int main()
{

	string s; // 반복자[클래스]를 제공해야함. 
	// 반복자는 클래스로 코딩해야하만 한다. why? 반복자의 타입을 알수있게하기위해서
	// 역방향반복자는 사기동작을 하므로 반드시 클래스로 만들어야한다.

	f(s.begin());

	/*cout << s << endl;*/
	save("STL.cpp");

	

}

=============================================== 
STL.cpp 2024-05-09 목요일 오후 1:50:20
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
// 6월 6일 강의 예정
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

//string => contigous 메모리이며 sequence container 이다.
// string 이 STL containter 가되려면 , iterator 를 제공해야함.
// string::value_type 
template <typename T>
void f(T iter)
{
	cout << typeid(iterator_traits<T>::iterator_category).name() << endl;

	cout << typeid(T::iterator_concept).name() << endl;
}


int main()
{

	string s; // 반복자[클래스]를 제공해야함. 
	// 반복자는 클래스로 코딩해야하만 한다. why? 반복자의 타입을 알수있게하기위해서
	// 역방향반복자는 사기동작을 하므로 반드시 클래스로 만들어야한다.
	
	f(s.begin());
	
	save("STL.cpp");

	

}

=============================================== 
STL.cpp 2024-05-09 목요일 오후 3:27:13
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
// 6월 6일 강의 예정
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;
//
//template<class 반복자, class 호출가능타입>
//반복자 my_find(반복자 b, 반복자 e, 호출가능타입 f)
//{
//	return 반복자
//}

int main()
{
	//[문제] 연산자 오버로딩  
	//다음문장이 문제없이 실행될수있도록 필요한 모든 코딩을 하라.


	String s{ "1357924680" };

	sort(s.begin(),s.end());

	cout << s << endl;

	// [문제 ] 다음 코드가 문제없이 실행되도록 하자 .
	//이코드는 [begin end] 에서 주어진 조건에 맞는 원소의 위치를 리턴한다. 

	//auto p = my_find(s.begin(), s.end(), [](char c) {
	//	if (stoi(c) % 2 == 0) {
	//		return true;
	//	}
	//	return false;
	//	});

	//cout << "처음 찾은 짝수의 위치는 " << endl;
	//cout << "처음 찾은 짝수의 값은" << endl;

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-09 목요일 오후 3:28:19
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
// 
// 6월 6일 강의 예정
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;
//
//template<class 반복자, class 호출가능타입>
//반복자 my_find(반복자 b, 반복자 e, 호출가능타입 f)
//{
//	return 반복자
//}
class test
{

public:
	int num=10;

	int getNum() const {
		return num;
	}
};
int main()
{

	test a;

	a.getNum();


	// [문제 ] 다음 코드가 문제없이 실행되도록 하자 .
	//이코드는 [begin end] 에서 주어진 조건에 맞는 원소의 위치를 리턴한다. 

	//auto p = my_find(s.begin(), s.end(), [](char c) {
	//	if (stoi(c) % 2 == 0) {
	//		return true;
	//	}
	//	return false;
	//	});

	//cout << "처음 찾은 짝수의 위치는 " << endl;
	//cout << "처음 찾은 짝수의 값은" << endl;

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:18:35
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.


	cout << "찾을 문자는?";
	char c;
	cin >> c;


	auto it = my_find_if(s.begin(), s.end(), [](char c) {
		if (isdigit(c)) 
		{
			if ((c & 1) == 0)//짝수인지 판단하는 코드 
			{
				return true;
			}
		}
		return false;
		});

	if (it != s.end()) {
		cout << *it  << "는 s의" <<
			distance(s.begin(), it) + 1
			<< "번 문자입니다." << endl;
	}
	else
	{
		cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
	}




	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:18:40
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.


	cout << "찾을 문자는?";
	char c;
	cin >> c;


	auto it = my_find_if(s.begin(), s.end(), [](char c) {
		if (isdigit(c)) 
		{
			if ((c & 1) == 0)//짝수인지 판단하는 코드 
			{
				return true;
			}
		}
		return false;
		});

	if (it != s.end()) {
		cout << *it  << "는 s의" <<
			distance(s.begin(), it) + 1
			<< "번 문자입니다." << endl;
	}
	else
	{
		cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
	}




	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:18:50
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.


	auto it = my_find_if(s.begin(), s.end(), [](char c) {
		if (isdigit(c)) 
		{
			if ((c & 1) == 0)//짝수인지 판단하는 코드 
			{
				return true;
			}
		}
		return false;
		});

	if (it != s.end()) {
		cout << *it  << "는 s의" <<
			distance(s.begin(), it) + 1
			<< "번 문자입니다." << endl;
	}
	else
	{
		cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
	}




	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:19:21
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.


	auto it = my_find_if(s.begin(), s.end(), [](char c) {
		if (isdigit(c)) 
		{
			if ((c & 1) == 0)//짝수인지 판단하는 코드 
			{
				return true;
			}
		}
		return false;
		});

	if (it != s.end()) {
		cout << *it  << "는 s의" <<
			distance(s.begin(), it) + 1
			<< "번 문자입니다." << endl;
	}
	else
	{
		cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
	}




	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:26:07
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 모두 출력하라.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.


	auto it = my_find_if(s.begin(), s.end(), [](char c) {
		if (isdigit(c)) 
		{
			if ((c & 1) == 0)//짝수인지 판단하는 코드 
			{
				return true;
			}
		}
		return false;
		});


	if (it != s.end()) {
		cout << *it << "는 s의" <<
			distance(s.begin(), it) + 1
			<< "번 문자입니다." << endl;
	}
	else
	{
		cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
	}


	



	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:29:19
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 모두 출력하라.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.

	auto p = s.begin();

	while (p != s.end())
	{
		auto it = my_find_if(p, s.end(), [](char c) {
			if (isdigit(c))
			{
				if ((c & 1) == 0)//짝수인지 판단하는 코드 
				{
					return true;
				}
			}
			return false;
			});

		if (it != s.end()) {
			cout << *it << "는 s의" <<
				distance(s.begin(), it) + 1
				<< "번 문자입니다." << endl;
		}
		else
		{
			cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
		}

		++p;
	}

	



	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:30:17
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 모두 출력하라.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.

	auto beg = s.begin();

	while (beg != s.end())
	{
		auto it = my_find_if(beg, s.end(), [](char c) {
			if (isdigit(c))
			{
				if ((c & 1) == 0)//짝수인지 판단하는 코드 
				{
					return true;
				}
			}
			return false;
			});

		if (it != s.end()) {
			cout << *it << "는 s의" <<
				distance(s.begin(), it) + 1
				<< "번 문자입니다." << endl;
		}
		else
		{
			cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
			break;
		}

		beg = it + 1;
	}

	



	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:30:41
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "1357924680 stl algorithm" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 모두 출력하라.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.

	auto beg = s.begin();

	while (true)
	{
		auto it = my_find_if(beg, s.end(), [](char c) {
			if (isdigit(c))
			{
				if ((c & 1) == 0)//짝수인지 판단하는 코드 
				{
					return true;
				}
			}
			return false;
			});

		if (it != s.end()) {
			cout << *it << "는 s의" <<
				distance(s.begin(), it) + 1
				<< "번 문자입니다." << endl;
		}
		else
		{
			cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
			break;
		}

		beg = it + 1;
	}

	



	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:31:11
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;

template<typename 반복자,typename 값> 
반복자 my_find(반복자 b, 반복자 e, 값 val)
{
	while(b != e) 
	{
		if (*b == val) 
			return b;
		
		++b;
	}

	return e;
}

//callable type 중에서 boolean 을 리턴하는 것을 predicate 이라고 부른다.
template<typename 반복자, typename 조건문>
반복자 my_find_if(반복자 b, 반복자 e, 조건문 f)
{
	while (b != e)
	{
		if( f( *b ))
			break;

		++b;
	}
	return b;
}

int main()
{



	String s{ "stl algorithm 1357924680" };

	//[문제] s 에 사용자가 찾는 조건(짝수) 에 맞는 문자가 있는지 알려주자.
	// 모두 출력하라.
	// 그 찾는 문자가 있다면 몇번째 문자인지 알려주자.
	// 없다면 없다고 출력하자.

	auto beg = s.begin();

	while (true)
	{
		auto it = my_find_if(beg, s.end(), [](char c) {
			if (isdigit(c))
			{
				if ((c & 1) == 0)//짝수인지 판단하는 코드 
				{
					return true;
				}
			}
			return false;
			});

		if (it != s.end()) {
			cout << *it << "는 s의" <<
				distance(s.begin(), it) + 1
				<< "번 문자입니다." << endl;
		}

		else
		{
			cout << "조건에 맞는 문자 는 존재하지 않습니다." << endl;
			break;
		}

		beg = it + 1;
	}

	



	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:34:41
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

using namespace std;



int main()
{



	String s{ "STL algorithm  2024년 5월 14일"};

	copy(s.begin(), s.end(), ostream_iterator<char>{cout});


	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:42:52
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

//using namespace std;
//_EXPORT_STD template <class _InIt, class _OutIt>
//_CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
//    _Adl_verify_range(_First, _Last);
//    const auto _UFirst = _Get_unwrapped(_First);
//    const auto _ULast = _Get_unwrapped(_Last);
//    const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
//    _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
//    return _Dest;
//}

template<typename initer,typename outlter> 
void my_copy(initer b, initer e, outlter d) 
{
	while (b != e) {
		*d = *b;
		++b;
	}
}


int main()
{



	String s{ "STL algorithm  2024년 5월 14일"};

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});


	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:43:30
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"

//using namespace std;
//_EXPORT_STD template <class _InIt, class _OutIt>
//_CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
//    _Adl_verify_range(_First, _Last);
//    const auto _UFirst = _Get_unwrapped(_First);
//    const auto _ULast = _Get_unwrapped(_Last);
//    const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
//    _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
//    return _Dest;
//}

template<typename initer,typename outlter> 
void my_copy(initer b, initer e, outlter d) 
{
	while (b != e) {
		*d = *b;
		++b;
	}
}


int main()
{



	String s{ "STL algorithm  2024년 5월 14일"};

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});


	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:49:13
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"


template<typename initer,typename outlter> 
void my_copy(initer b, initer e, outlter d) 
{
	while (b != e) {
		*d = *b;
		++b;
		++d;
	}
}


int main()
{



	String s{ "STL algorithm  2024년 5월 14일"};
	vector<char> v;

	v.resize(s.GetLen());

	my_copy(s.begin(), s.end(), v.begin());


	for (auto c : v) {
		cout << c;
	}


	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:50:38
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"


template<typename initer,typename outlter> 
void my_copy(initer b, initer e, outlter d) 
{
	while (b != e) {
		*d = *b;
		++b;
		++d;
	}
}


int main()
{



	String s{ "STL algorithm  2024년 5월 14일"};
	vector<char> v;

	v.reserve(s.GetLen());

	my_copy(s.begin(), s.end(), v.begin());


	for (auto c : v) {
		cout << c;
	}


	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-14 화요일 오후 2:57:19
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 9일 목 10주 2일
// 
// 반복자 에 대해 공부해보자 . 
// 
// 반복자는 포인터를 일반화한것 WHY? : c++ 에서 서로다른자료형 에 일관된 방식으로 코딩하려고
//  알고리즘 함수 - 반복자를 인자로 받는다.
//  Design pattern -> 문제를 우회하여 해결함
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"


template<typename initer,typename outlter> 
void my_copy(initer b, initer e, outlter d) 
{
	while (b != e) {
		*d = *b;
		++b;
		++d;
	}
}


int main()
{
	String s{ "STL algorithm  2024년 5월 14일"};
	vector<char> v;
	//v.resize(s.GetLen());

	//adapater

	my_copy(s.begin(), s.end(),  back_inserter(v));

	for (auto c : v) {
		cout << c;
	}

	cout << endl;

	for (int i = 0; i < s.GetLen(); ++i)
	{
		cout << v[i];
	}

	cout << endl;

	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-16 목요일 오후 1:25:13
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 14일 목 11주 1일
// 
// STL containers  => sequence => sort 되있다면 이진탐색때문에 ( O(logN)
// Associate(키와밸류연관) ( 찾기실력굳 (O(logN)))  
// unordered Associative (찾기실력베리굳(unordered Assocaite(O(1),공간을 희생함)
// 
// 
// 6월 6일 강의 예정
// 6월 13일 목요일 -> (15주 2일 ) ==> 기말시험
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"


template<typename initer,typename outlter> 
void my_copy(initer b, initer e, outlter d) 
{
	while (b != e) {
		*d = *b;
		++b;
		++d;
	}
}


int main()
{
	String s{ "STL algorithm  2024년 5월 14일"};
	vector<char> v;


	my_copy(s.begin(), s.end(), back_inserter(v));

	for (auto c : v) {
		cout << c;
	}

	cout << endl;

	for (int i = 0; i < s.GetLen(); ++i)
	{
		cout << v[i];
	}

	cout << endl;

	save("STL.cpp");

};

=============================================== 
STL.cpp 2024-05-16 목요일 오후 1:37:31
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 16일 목 11주 2일
// 
// Associative Container - set / map

//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"
#include <set>


set<int> s;


int main()
{
	//[문제] 사용자가 입력한 모든 단어를 오름차순으로 정렬한후 출력하라.
	
	관찰 = true;

	set<String> s{ istream_iterator<String>{cin},{} };

	관찰 = false;

	for (auto& i : s) {
		cout << i << endl;
	}
	



	save("STL.cpp");
};

=============================================== 
STL.cpp 2024-05-16 목요일 오후 1:37:43
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 16일 목 11주 2일
// 
// Associative Container - set / map

//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"
#include <set>


set<int> s;


int main()
{
	//[문제] 사용자가 입력한 모든 단어를 오름차순으로 정렬한후 출력하라.
	
	관찰 = true;

	set<String> s{ istream_iterator<String>{cin},{} };

	관찰 = false;

	for (auto& i : s) {
		cout << i << endl;
	}
	



	save("STL.cpp");
};

=============================================== 
STL.cpp 2024-05-16 목요일 오후 2:13:25
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 16일 목 11주 2일
// 
// Associative Container - set / map
// -equivalence(동등성,<) /equality(상등성,==) 
// -default 정렬기준은 operator< (less) 이다. 다른 정렬기준을 주고싶다면 
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"
#include <set>


class 길이오름차순
{
public:
	bool operator()(const String& a, const String& b) const
	{
		return a.GetLen() < b.GetLen();
	};

};



set<int> s;


int main()
{
	
	ifstream in{ "STL.cpp"};



	//set<String, bool(*)(const String&, const String&)> s{istream_iterator<String>{in},{},길이오름차순};
	multiset<String, 길이오름차순> s{ istream_iterator<String>{in},{} };

	for (auto& i : s) {
		cout << i << endl;
	}
	



	save("STL.cpp");
};

=============================================== 
STL.cpp 2024-05-16 목요일 오후 2:28:04
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 16일 목 11주 2일
// 
// Associative Container - set / map
// -equivalence(동등성,<) /equality(상등성,==) 
// -default 정렬기준은 operator< (less) 이다. 다른 정렬기준을 주고싶다면  클래스로 스펠라제이션
// 
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"
#include <set>


class 길이오름차순
{
public:
	bool operator()(const String& a, const String& b) const
	{
		return a.GetLen() < b.GetLen();
	};

};

template<>
struct less<String>
{
	//영단어 가먼저나오고 , 한글이 이후나옴
public:
	bool operator()(const String& a, const String& b) const {
		// a,b => 영/영 , 영/한 , 한/영 , 한/한  ,
		// 즉 첫글자를 기준으로 바꾼다
		if (!isalpha(*(a.begin())) && isalpha(*(b.begin())))
			return false;
		return true;
 	}
};



set<int> s;


int main()
{
	
	ifstream in{ "STL.cpp"};



	//set<String, bool(*)(const String&, const String&)> s{istream_iterator<String>{in},{},길이오름차순};
	multiset<String> s{ istream_iterator<String>{in},{} };

	for (auto& i : s) {
		cout << i << endl;
	}
	

	save("STL.cpp");
};

=============================================== 
STL.cpp 2024-05-16 목요일 오후 2:48:01
=============================================== 

//-----------------------------------------------------------------------------
//  
// 5월 16일 목 11주 2일
// 
// Associative Container - set / map
// -equivalence(동등성,<) /equality(상등성,==) 
// -default 정렬기준은 operator< (less) 이다. 다른 정렬기준을 주고싶다면  클래스로 스펠라제이션
// 
// 
//----------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <print>
#include <random>
#include <string>
#include <vector>
#include <forward_list>
#include "Mystring.h"
#include <span>
#include "Mystring.h"
#include <set>


class 길이오름차순
{
public:
	bool operator()(const String& a, const String& b) const
	{
		return a.GetLen() < b.GetLen();
	};

};

template<>
struct less<String>
{
	//영단어 가먼저나오고 , 한글이 이후나옴
public:
	bool operator()(const String& a, const String& b) const {
		// a,b => 영/영 , 영/한 , 한/영 , 한/한  ,
		// 즉 첫글자를 기준으로 바꾼다
		if (!isalpha(*(a.begin())) && isalpha(*(b.begin())))
			return false;
		return true;
 	}
};



set<int> s;


int main()
{
	ifstream in{ "이상한 나라의 앨리스.txt" };

	if (not in) {
		return -111;
	}

	set<String> s{ istream_iterator <String>{in},{} };

	cout << "읽은단어수: "<< s.size() << endl;

	for (const String& i : s) {
		cout << i << " ";
	}
	cout << endl;

	save("STL.cpp");
};

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:32:26
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > m;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			m[towlower(c)]++;
		}
	}

	for (auto [소문자, 횟수] : m) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:39:42
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > cim;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			cim[towlower(c)]++;
		}
	}

	//for (auto [소문자, 횟수] : m) {
	//	cout << 소문자 << " -" << 횟수 << endl;
	//}

	cout << endl;
	//횟수기준 내림차순으로 정렬

	map<int, char,less<int>> m2;

	for (auto [소문자, 횟수] : cim) {
		m2[횟수] = 소문자;
	}


	for (auto [횟수, 소문자] : m2) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:39:49
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > cim;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			cim[towlower(c)]++;
		}
	}

	//for (auto [소문자, 횟수] : m) {
	//	cout << 소문자 << " -" << 횟수 << endl;
	//}

	cout << endl;
	//횟수기준 내림차순으로 정렬

	map<int, char,greater<int>> m2;

	for (auto [소문자, 횟수] : cim) {
		m2[횟수] = 소문자;
	}


	for (auto [횟수, 소문자] : m2) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:40:31
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > cim;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			cim[towlower(c)]++;
		}
	}

	//for (auto [소문자, 횟수] : m) {
	//	cout << 소문자 << " -" << 횟수 << endl;
	//}

	cout << endl;
	//횟수기준 내림차순으로 정렬

	multimap<int, char,greater<int>> m2;

	for (auto [소문자, 횟수] : cim) {
		/*m2[횟수] = 소문자;*/
		m2.insert(make_pair<int, char>(소문자, 횟수));
	}


	for (auto [횟수, 소문자] : m2) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:41:47
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > cim;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			cim[towlower(c)]++;
		}
	}

	//for (auto [소문자, 횟수] : m) {
	//	cout << 소문자 << " -" << 횟수 << endl;
	//}

	cout << endl;
	//횟수기준 내림차순으로 정렬

	multimap<int, char> m2;

	for (auto [소문자, 횟수] : cim) {
		/*m2[횟수] = 소문자;*/
		m2.insert(make_pair<int, char>(소문자, 횟수));
	}


	for (auto [횟수, 소문자] : m2) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:44:52
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > cim;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			cim[towlower(c)]++;
		}
	}

	for (auto [소문자, 횟수] : cim) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	cout << endl;
	//횟수기준 내림차순으로 정렬

	multimap<int, char> icm;

	for (auto [소문자, 횟수] : cim) {

		icm.insert(make_pair(횟수,소문자));
	}


	for (auto [횟수,소문자] : icm) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:47:18
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > cim;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			cim[towlower(c)]++;
		}
	}

	for (auto [소문자, 횟수] : cim) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	cout << endl;
	//횟수기준 내림차순으로 정렬

	multimap<int, char> icm;

	for (auto [소문자, 횟수] : cim) {

		icm.insert(make_pair(횟수,소문자));
	}


	for (auto [횟수, 소문자] : icm | views::reverse) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 1:47:28
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>

#include "Mystring.h"

using namespace std;

//
// map<Key, Value> - dictionary

int main()
{

	map<char, int > cim;

	ifstream in{ "이상한 나라의 앨리스.txt" };


	char c;

	while (in >> c)
	{
		if (isalpha(c)) {
			cim[towlower(c)]++;
		}
	}

	for (auto [소문자, 횟수] : cim) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	cout << endl;
	//횟수기준 내림차순으로 정렬

	multimap<int, char> icm;

	for (auto [소문자, 횟수] : cim) {

		icm.insert(make_pair(횟수,소문자));
	}


	for (auto [횟수, 소문자] : icm ) {
		cout << 소문자 << " -" << 횟수 << endl;
	}

	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 2:13:12
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>

#include "Mystring.h"
#include <random>

default_random_engine dre;
uniform_int_distribution<int> uid{1, 10'0000-1};
using namespace std;


int main()
{
	//[문제] uniform 분포는 uniform 한가?
	// 출현 숫자를 10구간으로 나누어 출현횟수를 화면에 출력하라.
	map<int, int> m; //구간,숫자

	for (int i = 0; i < 1000'0000; ++i)
	{
		m[uid(dre) / 5000]++;
	}

	for (auto [구간, 횟수] : m) {
		cout << 구간 << "-" << 횟수 << endl;
	}


	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 2:20:49
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>

#include "Mystring.h"
#include <random>

default_random_engine dre;
uniform_int_distribution<int> uid{1, 10'0000-1};
normal_distribution<double> nom{ 0.0, 0.1 };//평균값, 분포도
using namespace std;


int main()
{
	//[문제] normal 분포는 normal 한가?
	// 출현 숫자를 10구간으로 나누어 출현횟수를 화면에 출력하라.
	map<int, int> m; //구간,숫자

	for (int i = 0; i < 100; ++i)
	{
		cout << nom(dre) << endl;
	}




	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-23 목요일 오후 2:48:50
=============================================== 

#include <iostream>
#include <fstream>
#include <iomanip>

#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>

#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>


default_random_engine dre;
uniform_int_distribution<int> uid{1, 10'0000-1};
normal_distribution<double> nom{ 0, 0.2};//평균값, 분포도
using namespace std;

// STL_CONTAINER  unordered_set (o1), unordered_map (o1) => 표로 만들어놓음
// unordered_set<key>  us ;  us.find("the); 즉시 o1 시간만에 알려줌
// 키가 저장된 곳을 바로아는 메커니즘 임
// 즉 테이블 을 이용하여 상수시간만에 찾아줌.
// 순서가 없다는것은 ? 
// 메모리를 어떻게 사용하길래 o(1) 만에 찾아줄까?
//  내가만든 string 을 저장하려면 어떻게?
int main()
{
	//[문제] normal 분포는 normal 한가?
	// 출현 숫자를 10구간으로 나누어 출현횟수를 화면에 출력하라.
	

	unordered_set<int> s{ 3,1,4,2 };

	s.insert(10);

	//시퀀스 컨테이너가 아님@@@
	for (auto i : s) {
		cout << i << endl;
	}






	save("STL.cpp");

}

=============================================== 
STL.cpp 2024-05-28 화요일 오후 2:37:36
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//
//
//
//
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>


uniform_int_distribution<int> uid(1, 1000'0000);
default_random_engine dre;

const int NUM = 1000'0000;
const int FNUM = 10'0000;

array<int, NUM> a;
array<int, FNUM> fa;

using namespace std;

//STL CONTANINER 찾기실력 검증
// 1. vector 정렬안瑛 o(n)/ 정렬瑛 o(logn)  2. multiset o(logn) , 3. unordered_multiset o(1)
// 벡터에서 찾기 (정렬 x) : 	걸린 시간 : 98154
// 벡터에서 찾기 (정렬 o) :     28 [포인터를 i아가는거보다 랜덤액세스가 더빠름] => flat_set(c++23)
// multiset 에서 찾기     :     88 [포인터를 i아감 트리구조이므로]
// 언오더드 셋            :     3 
int main()
{
	


	for (int& num : a)
		num = uid(dre);

	for (int& num : fa)
		num = uid(dre);

	//벡터 준비 중...

	//	걸린 시간 : 98154
	//	63170개를 찾았다.
	//{
	//	cout << "벡터 준비 중..." << endl;
	//	vector<int> v{ a.begin(),a.end() };
	//	cout << endl;

	//	int cnt{};

	//	auto start = std::chrono::high_resolution_clock::now();

	//	for (int num : fa)
	//	{
	//		auto it =  find(v.begin(), v.end(), num);

	//		if (it != v.end())
	//		{
	//			++cnt;
	//		}
	//	}

	//	auto end = std::chrono::high_resolution_clock::now();


	//	auto elapsedTime = chrono::duration_cast<chrono::milliseconds>(end - start);
	//	cout << "걸린 시간 :" << elapsedTime.count() << endl;
	//	cout << cnt << "개를 찾았다." << endl;
	//}


	//셋 준비 중...

	//	걸린 시간 : 114
	//	63170개를 찾았다.
	{
		cout << "셋 준비 중..." << endl;
		multiset<int> s{ a.begin(),a.end() };
		cout << endl;

		int cnt{};

		auto start = std::chrono::high_resolution_clock::now();

		for (int num : fa)
		{
			bool find = s.contains(num);

			if (find) {
				++cnt;
			}
		}

		auto end = std::chrono::high_resolution_clock::now();


		auto elapsedTime = chrono::duration_cast<chrono::milliseconds>(end - start);
		cout << "걸린 시간 :" << elapsedTime.count() << endl;
		cout << cnt << "개를 찾았다." << endl;
	}

	////걸린 시간 : 4
	////	63170개를 찾았다.
	{
		cout << "언오더드셋 준비 중..." << endl;
		unordered_multiset<int> us{ a.begin(),a.end() };
		cout << endl;

		int cnt{};

		auto start = std::chrono::high_resolution_clock::now();

		for (int num : fa)
		{
			bool find = us.contains(num);

			if (find) {
				++cnt;
			}
		}

		auto end = std::chrono::high_resolution_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::milliseconds>(end - start);
		cout << "걸린 시간 :" << elapsedTime.count() << endl;
		cout << cnt << "개를 찾았다." << endl;
	}

	{
		cout << "벡터(정렬된것) 준비 중..." << endl;
		vector<int> v{ a.begin(),a.end() };
		cout << endl;
		sort(v.begin(), v.end());
		int cnt{};

		auto start = std::chrono::high_resolution_clock::now();

		for (int num : fa)
		{
			bool find = binary_search(v.begin(), v.end(),num);

			if (find) cnt++;

		}

		auto end = std::chrono::high_resolution_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::milliseconds>(end - start);
		cout << "걸린 시간 :" << elapsedTime.count() << endl;
		cout << cnt << "개를 찾았다." << endl;
		cout << endl;
	}

	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-05-30 목요일 오후 2:17:25
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	is_partitioned(v.begin(), v.end()); => 로 구분되어있냐?
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>


using namespace std;

//STL CONTANINER 찾기실력 검증
// 1. vector 정렬안瑛 o(n)/ 정렬瑛 o(logn)  2. multiset o(logn) , 3. unordered_multiset o(1)
// 벡터에서 찾기 (정렬 x) : 	걸린 시간 : 98154
// 벡터에서 찾기 (정렬 o) :     28 [포인터를 i아가는거보다 랜덤액세스가 더빠름] => flat_set(c++23) (컨테이너는 아님, 어댑터임)
// multiset 에서 찾기     :     88 [포인터를 i아감 트리구조이므로]
// 언오더드 셋            :     3 

template<typename 반복자, typename 조건문>
bool my_all_of(반복자 start, 반복자 end, 조건문 f)
{
	if (start == end) return true;

	while (start != end) {
		if (!f(*start)) {
			return false;
		}
		++start;
	}
	return true;

}

int main()
{
	vector<int> v{ 1,3,5,7,9,1};
	//v에 홀수만 있니?
	bool result =my_all_of(v.begin(), v.end(), [](const int a) {return a & 1; });

	if (result) {
		cout << "모두 홀수이다." << endl;
	}

	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-05-30 목요일 오후 2:18:55
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	is_partitioned(v.begin(), v.end()); => 로 구분되어있냐?
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>


using namespace std;

//STL CONTANINER 찾기실력 검증
// 1. vector 정렬안瑛 o(n)/ 정렬瑛 o(logn)  2. multiset o(logn) , 3. unordered_multiset o(1)
// 벡터에서 찾기 (정렬 x) : 	걸린 시간 : 98154
// 벡터에서 찾기 (정렬 o) :     28 [포인터를 i아가는거보다 랜덤액세스가 더빠름] => flat_set(c++23) (컨테이너는 아님, 어댑터임)
// multiset 에서 찾기     :     88 [포인터를 i아감 트리구조이므로]
// 언오더드 셋            :     3 

template<typename 반복자, typename 조건문>
bool my_all_of(반복자 start, 반복자 end, 조건문 f)
{
	if (start == end) return true;

	while (start != end) 
	{
		if (!f(*start)) return false;
		++start;
	}
	return true;

}

int main()
{
	vector<int> v{ 1,3,5,7,9,1};
	//v에 홀수만 있니?
	bool result =my_all_of(v.begin(), v.end(), [](const int a) {return a & 1; });

	if (result) {
		cout << "모두 홀수이다." << endl;
	}

	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-05-30 목요일 오후 2:26:04
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	is_partitioned(v.begin(), v.end()); => 로 구분되어있냐?
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>


using namespace std;
random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int>uid(1, 45);

//로또번호 추출기 만들어보기


int main()
{
	vector<int> v(45);

	iota(v.begin(), v.end(), 1);

	sample(v.begin(), v.end(), ostream_iterator<int>{cout," "},6,dre);


	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-05-30 목요일 오후 3:00:24
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	정렬관련 알고리즘 복잡도 순으로 
//	partition  - 조건에 따라 분리
// ,nth_element  -  n등까지와 나머지로 분리 [선착순]
// ,partial_sort  - n등까지는 정렬된 상태로 나머지는 무관
// ,sort          - 전체정렬
// ,stable_sort
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;
random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int>uid(1, 45);



int main()
{	
	vector<int> v(100);

	iota(v.begin(), v.end(), 1);


	cout << endl;

	//파티션에 대해 알아 보자
	{
		//조건에 맞는것과 아닌것으로 분리한다.
		//홀짝으로 분리하고 각각으로 출력하라.
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		auto p= partition(v.begin(), v.end(), [](int n) {return n & 1; });
		cout << " 홀수 " << endl;
		for (auto i = v.begin(); i != p; ++i) 
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
		cout << " 짝수 " << endl;
		for (auto i = p; i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
	}

	//nth_element 대해 알아 보자
	{
		// n번째와 나머지로 분리하라 
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		nth_element(v.begin(),v.begin()+30,v.end());
		cout << " 30등까지 " << endl;
		for (auto i = v.begin(); i != v.begin()+30; ++i)
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
		cout << " 나머지 " << endl;
		for (auto i = v.begin()+30; i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
	}

	//parital_sort 대해 알아 보자
	{
		// n번째까지만 정렬 나머지로 분리하라 
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		partial_sort(v.begin(), v.begin() + 30, v.end());
		cout << " 30등까지 " << endl;
		for (auto i = v.begin(); i != v.begin() + 30; ++i)
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
		cout << " 나머지 " << endl;
		for (auto i = v.begin() + 30; i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
	}


	//sort 대해 알아 보자
	{
		
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		sort(v.begin(), v.end());

		for (auto i = v.begin(); i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
	}


	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-05-30 목요일 오후 3:00:59
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	정렬관련 알고리즘 복잡도 순으로 
//	partition  - 조건에 따라 분리
// ,nth_element  -  n등까지와 나머지로 분리 [선착순]
// ,partial_sort  - n등까지는 정렬된 상태로 나머지는 무관
// ,sort          - 전체정렬
// ,stable_sort
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;
random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int>uid(1, 45);



int main()
{	
	vector<int> v(100);

	iota(v.begin(), v.end(), 1);


	cout << endl;

	//파티션에 대해 알아 보자
	{
		//조건에 맞는것과 아닌것으로 분리한다.
		//홀짝으로 분리하고 각각으로 출력하라.
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		auto p= partition(v.begin(), v.end(), [](int n) {return n & 1; });
		cout << " 홀수 " << endl;
		for (auto i = v.begin(); i != p; ++i) 
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
		cout << " 짝수 " << endl;
		for (auto i = p; i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
	}
	cout << " nth_element" << endl;
	//nth_element 대해 알아 보자
	{
		// n번째와 나머지로 분리하라 
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		nth_element(v.begin(),v.begin()+30,v.end());
		cout << " 30등까지 " << endl;
		for (auto i = v.begin(); i != v.begin()+30; ++i)
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
		cout << " 나머지 " << endl;
		for (auto i = v.begin()+30; i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
	}
	cout << " parital_sort" << endl;
	//parital_sort 대해 알아 보자
	{
		// n번째까지만 정렬 나머지로 분리하라 
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		partial_sort(v.begin(), v.begin() + 30, v.end());
		cout << " 30등까지 " << endl;
		for (auto i = v.begin(); i != v.begin() + 30; ++i)
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
		cout << " 나머지 " << endl;
		for (auto i = v.begin() + 30; i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
	}


	//sort 대해 알아 보자
	cout << " sort" << endl;
	{
		
		shuffle(v.begin(), v.end(), dre);

		for (int num : v) {
			print(cout, "{:4}", num);
		}
		cout << endl;
		cout << endl;
		sort(v.begin(), v.end());

		for (auto i = v.begin(); i != v.end(); ++i)
		{
			print(cout, "{:4}", *i);
		}
		cout << endl;
	}


	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-05-30 목요일 오후 3:10:51
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	정렬관련 알고리즘 복잡도 순으로 
//	partition  - 조건에 따라 분리
// ,nth_element  -  n등까지와 나머지로 분리 [선착순]
// ,partial_sort  - n등까지는 정렬된 상태로 나머지는 무관
// ,sort          - 전체정렬
// ,stable_sort
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;
random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int>uid(1, 45);
uniform_int_distribution<int>uidC('A', 'Z');
struct  Dog
{
	Dog()
	{
		c = uidC(dre);
		n = uid(dre);
	}
	char c;
	int n;
};

int main()
{	
	array<Dog,100> dogs;

	sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) 
		{return dog1.c < dog2.c; }
	);

	for (auto [글자,숫자] : dogs) {
		cout << 글자 << " ," << 숫자 << endl;
	}



	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 1:41:19
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	정렬관련 알고리즘 복잡도 순으로 
//	partition  - 조건에 따라 분리
// ,nth_element  -  n등까지와 나머지로 분리 [선착순]
// ,partial_sort  - n등까지는 정렬된 상태로 나머지는 무관
// ,sort          - 전체정렬
// ,stable_sort
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;
random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int>uid(1, 45);
uniform_int_distribution<int>uidC('A', 'Z');
struct  Dog
{

	char c = uidC(dre);
	int n{ uid(dre) };

};

int main()
{	
	array<Dog,100> dogs;

	/*sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) 
		{return dog1.c < dog2.c; }
	);*/

	
	/*ranges::sort(dogs, [](const Dog& dog1, const Dog& dog2)
		{return dog1.c < dog2.c; });*/

	ranges::sort(dogs, {}, &Dog::c);






	for (auto& [글자,숫자] : dogs) {
		cout << 글자 << " ," << 숫자 << endl;
	}



	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 1:41:32
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	정렬관련 알고리즘 복잡도 순으로 
//	partition  - 조건에 따라 분리
// ,nth_element  -  n등까지와 나머지로 분리 [선착순]
// ,partial_sort  - n등까지는 정렬된 상태로 나머지는 무관
// ,sort          - 전체정렬
// ,stable_sort
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;
random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int>uid(1, 45);
uniform_int_distribution<int>uidC('A', 'Z');
struct  Dog
{

	char c = uidC(dre);
	int n{ uid(dre) };

};

int main()
{	
	array<Dog,100> dogs;

	/*sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) 
		{return dog1.c < dog2.c; }
	);*/

	
	/*ranges::sort(dogs, [](const Dog& dog1, const Dog& dog2)
		{return dog1.c < dog2.c; });*/

	ranges::sort(dogs, {}, &Dog::c);

	ranges::sort(dogs, {}, &Dog::n);




	for (auto& [글자,숫자] : dogs) {
		cout << 글자 << " ," << 숫자 << endl;
	}



	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 1:42:35
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
//  unordered set /map  -> 테이블
//  13주 2일째 - 
//
//	정렬관련 알고리즘 복잡도 순으로 
//	partition  - 조건에 따라 분리
// ,nth_element  -  n등까지와 나머지로 분리 [선착순]
// ,partial_sort  - n등까지는 정렬된 상태로 나머지는 무관
// ,sort          - 전체정렬
// ,stable_sort
//	
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;
random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int>uid(1, 45);
uniform_int_distribution<int>uidC('A', 'Z');
struct  Dog
{

	char c = uidC(dre);
	int n{ uid(dre) };

};

int main()
{	
	array<Dog,100> dogs;

	/*sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) 
		{return dog1.c < dog2.c; }
	);*/

	
	/*ranges::sort(dogs, [](const Dog& dog1, const Dog& dog2)
		{return dog1.c < dog2.c; });*/

	ranges::sort(dogs, {}, &Dog::c);

	ranges::stable_sort(dogs, {}, &Dog::n);




	for (auto& [글자,숫자] : dogs) {
		cout << 글자 << " ," << 숫자 << endl;
	}



	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 1:49:52
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
// 14주 1일
// 
// 
// STL Alogrithm  => non modifying   / modifying   /  sort and realated 
// non modifying: copy(src,dest) :
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;

int main()
{	
	array<int, 10> a{ 1,2,3,4,5,6,7,8,9,10 };

	copy(a.begin(), a.end(), ostream_iterator<int>{cout, " "});


	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 1:54:41
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
// 14주 1일
// 
// 
// STL Alogrithm  => non modifying   / modifying   /  sort and realated 
// non modifying: copy(src,dest) :
//
//
// distacne 구현
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;

int main()
{	
	list<int> v{ 1,2,3,4,5 };

	auto i = distance(v.begin(), v.end());
	cout << i << endl;
	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 1:55:46
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
// 14주 1일
// 
// 
// STL Alogrithm  => non modifying   / modifying   /  sort and realated 
// non modifying: copy(src,dest) :
//
//
// distacne 구현
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>


using namespace std;

int main()
{	
	list<int> v{ 1,2,3,4,5 };

	auto i = distance(v.end(), v.begin());
	cout << i << endl;
	save("STL.cpp");
	

}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 2:58:45
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
// 14주 1일
// 
// 
// STL Alogrithm  => non modifying   / modifying   /  sort and realated 
// non modifying: copy(src,dest) :
//
//
// distacne 구현
// tag dispatching
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>
#include <forward_list>

using namespace std;


template <typename T>
T add(T a, T b) {
	return a + b;
}

int main()
{	
	cout << add(1, 3) << endl;
	cout << add(1.2, 3.4) << endl;
	cout << add<string>("2024년", "6월 4일") << endl;

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 2:59:22
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
// 14주 1일
// 
// 
// STL Alogrithm  => non modifying   / modifying   /  sort and realated 
// non modifying: copy(src,dest) :
//
//
// distacne 구현
// tag dispatching
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>
#include <forward_list>

using namespace std;


template <typename T>
T add(T a, T b) {
	return a + b;
}

int main()
{	
	cout << add(1, 3) << endl;
	cout << add(1.2, 3.4) << endl;
	cout << add("2024년"s, "6월 4일"s) << endl;

	save("STL.cpp");
}

=============================================== 
STL.cpp 2024-06-04 화요일 오후 3:04:51
=============================================== 

////////////////////////////////////////////////////////////////////////////////////////////////////
//     
// 14주 1일
// 
// 
// STL Alogrithm  => non modifying   / modifying   /  sort and realated 
// non modifying: copy(src,dest) :
//
//
// distacne 구현
// tag dispatching
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <ranges>
#include <array>
#include "Mystring.h"
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <numeric>
#include <thread>
#include <forward_list>

using namespace std;

template<class T>
concept 덧셈가능 = is_integral_v<T> || is_floating_point_v<T>;

template <덧셈가능 T>
T add(T a, T b) {
	return a + b; 
}

int main()
{	
	cout << add(1, 3) << endl;
	cout << add(1.2, 3.4) << endl;
	//cout << add("2024년", "6월 4일") << endl;

	save("STL.cpp");
}