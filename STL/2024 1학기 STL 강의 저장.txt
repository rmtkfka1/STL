//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 5일 화요일  (1주 1 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	/*for (char c : v)
	{
		cout << c;
	}*/

	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 5일 화요일  (1주 1 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	/*for (char c : v)
	{
		cout << c;
	}*/

	out << endl << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto time = chrono::system_clock::now(); // epoch 으로부터 흐른 tick

	cout << time << endl;

	// 2.시간형식으로 변환
	// 3.현지 시간으로 바꾼다.
	// 4.한국 형식으로 출력한다.
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : " << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto time = chrono::system_clock::now(); // epoch 으로부터 흐른 tick

	cout << time << endl;

	// 2.시간형식으로 변환
	// 3.현지 시간으로 바꾼다.
	// 4.한국 형식으로 출력한다.
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : " << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);

	cout << utc_time << endl;
	// 3.현지 시간으로 바꾼다.
	// 4.한국 형식으로 출력한다.
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : " << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});

}

=============================================== 
저장된 시간 : 03/07/24 Thursday 13:45:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5. 시간을 기록한다.
	// 
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : "<<put_time(lt,"%x %A %X") << endl;
	out << "=============================================== " << endl;


	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
저장된 시간 : 2024-03-07 목요일 오후 1:47:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// ===================================================//



	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : "<<put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;


	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
저장된 시간 : 2024-03-07 목요일 오후 1:49:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5.시간을 출력한다.
	out << endl << endl;
	out << "=============================================== " << endl;
	out << "저장된 시간 : "<<put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5.시간을 출력한다.
	out << endl << endl;
	out << "=============================================== " << endl;
	//out << "저장된 시간 : "<<put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
STL.cpp 2024-03-07 목요일 오후 1:52:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  VisualStudio 17.9 이상  Release/x64                                                                //
// 
//  할일 : 한학기 강의를 저장할 세이브 함수 작성하고 파일분리
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
	ifstream in{ fileName.data() }; //RAII

	if (!in)
	{
		cout << fileName << " 열기 실패" << endl;
		exit(0);
	}

	//cout << sizeof(in) << endl;
	//cout << addressof(in) << endl;
	//cout << typeid(in).name() << endl;



	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

	ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
	//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// ====================시간 출력하는 방법=========================//
	// 1.현재 time_point 를 얻는다.
	auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
	// 2.UTC 시간형식으로 변환
	auto utc_time = chrono::system_clock::to_time_t(now);
	// 3.현지 시간으로 바꾼다.
	auto lt = localtime(&utc_time);
	// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
	auto old = out.imbue(locale("ko_KR"));
	// 5.시간을 출력한다.
	out << endl << endl;
	out << "=============================================== " << endl;
	out << fileName<<" " << put_time(lt, "%x %A %X") << endl;
	out << "=============================================== " << endl;
	// 6.다시 원상복구한다.
	out.imbue(locale(old));
	// ===================================================//
	out << endl;
	copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
STL.cpp 2024-03-07 목요일 오후 1:56:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 
//-------------------------------------------------------------------------------------------------------
//#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include "save.h"

using namespace std;


void save(string_view);


int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 1:57:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:02:21
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:03:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " 2024 STL " << endl;
	save("STL.cpp");
}



=============================================== 
save.h 2024-03-07 목요일 오후 2:07:24
=============================================== 

#pragma once
#include <string_view>

//-----------------------------------------------------------------------------------------
// save.h 한학기 강의를 저장한다.
// 
// 2024 . 03 .07 
//------------------------------------------------------------------------------------------

void save(std::string_view fileName);

=============================================== 
save.cpp 2024-03-07 목요일 오후 2:07:24
=============================================== 

#include "save.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;

void save(string_view fileName)
{
	// 1. fileName 을 읽기용으로 연다.
	// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.
	// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 


		// 1. fileName 을 읽기용으로 연다.
		ifstream in{ fileName.data() }; //RAII

		if (!in)
		{
			cout << fileName << " 열기 실패" << endl;
			exit(0);
		}

		//cout << sizeof(in) << endl;
		//cout << addressof(in) << endl;
		//cout << typeid(in).name() << endl;



		// 2. 저장할 파일을 덧붙여 쓰기 모드로 연다.

		ofstream out{ "2024 1학기 STL 강의 저장.txt", ios::app };



		// 3.읽을 파일의 내용을 읽어 쓸 파일에 덧 붙인다. 
		//STL 자료구조와 알고리즘을 이용하여 기록한다 ( 좋은건 아니다.)

		vector<char> v{ istreambuf_iterator<char>{in},{} };

		// ====================시간 출력하는 방법=========================//
		// 1.현재 time_point 를 얻는다.
		auto now = chrono::system_clock::now(); // epoch 으로부터 흐른 tick
		// 2.UTC 시간형식으로 변환
		auto utc_time = chrono::system_clock::to_time_t(now);
		// 3.현지 시간으로 바꾼다.
		auto lt = localtime(&utc_time);
		// 4.한국 형식으로 출력한다. (출력스트림의 지역을 변환한다.)
		auto old = out.imbue(locale("ko_KR"));
		// 5.시간을 출력한다.
		out << endl << endl;
		out << "=============================================== " << endl;
		out << fileName << " " << put_time(lt, "%x %A %X") << endl;
		out << "=============================================== " << endl;
		// 6.다시 원상복구한다.
		out.imbue(locale(old));
		// ===================================================//
		out << endl;
		copy(v.begin(), v.end(), ostreambuf_iterator<char>{out});
}

=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:07:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
//  -VisualStudio 17.9 이상  Release/x64                                                               //
//	-C++ SDL검사 끄기                                                                                  //
// 
//  할일 : 한학기를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << " save 기능을 완성했다." << endl;
	save("save.h");
	save("save.cpp");
	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:26:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.


void change(int& n1, int& n2)
{
	swap(n1, n2);
}


int main()
{
	int a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:37:17
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


int main()
{
	int a{ 1 }, b{ 2 };


	change<int>(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 2:53:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog {
public:
	Dog(int a) : t(a) {}

	int getValue() const {
		return t;
	}

private:
	int t;
};


std::ostream& operator<<(std::ostream& os, const Dog& dog) {
	os << dog.getValue(); 
	return os;
}



int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:05:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  

	int getValue() const {
		return t;
	}

	operator int() { return t; }


private:
	int t;
};


//std::ostream& operator<<(std::ostream& os, const Dog& dog) {
//	os << dog.getValue(); 
//	return os;
//}



int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:08:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  

	int getValue() const {
		return t;
	}

	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.getValue();
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:20:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t << endl;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-07 목요일 오후 3:20:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:18:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:26:14
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a{ 1 }, b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:26:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 7일 화요일  (1주 2 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"

using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.

template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};





int main()
{
	Dog a(1), b{ 2 };


	change(a, b);

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");
}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:48:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <vector>
using namespace std;

//[문제] main() 을 손대지말고 의도대로 실행되도록 change() 을 선언하고 정의하라.


//generic programing -> 자료형에 무관한 코딩
template <typename T>
void change(T& n1, T& n2)
{
	swap(n1, n2);
}


class Dog 
{
public:
	Dog(int a) : t(a) {}

	//Dog(const Dog&) {}; -> specal fuction 이기에 자동생성  
	//operator int() { return t; }

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << dog.t;
		return os;
	}


private:
	int t;
};


int main()
{

	Dog a{  1 }, b{ 2 };

	change(a, b);
	//우선순위 1. change(dog , dog ) 가존재하나 ? 2. change(dog&, dog& ) 가 존재하나?
	//         3. 템플릿 코드 확장 

	cout << a << "," << b << endl; // 2,1

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<" ";
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<" ";
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:52:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<endl;
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:53:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 2);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<endl;
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 1:53:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 5);


//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<<endl;
	}


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:01:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << a[i]<< '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:04:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:04:30
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:<80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:04:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:^80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:^80}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:^8}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:8}",a[i]) << '\t';
	}

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:05:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << format("{:8}",a[i]) << '\t';
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:06:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		print(cout, "{:8}", a[i]);
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:07:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{
	int a[100];

	for (int i = 0; i < 100; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < 100; ++i)
	{
		print(cout, "{:8}", a[i]);
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:07:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) , 
//[문제] int 100개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 100개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{

	const int num = 100;

	int a[num];

	for (int i = 0; i < num; ++i)
	{
		a[i] = uid(dre);
	}

	for (int i = 0; i < num; ++i)
	{
		print(cout, "{:8}", a[i]);
	}
	cout << endl;

	/*for (int i : a)
	{
		cout << a[i] << '\t';
	}
	cout << endl;*/


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:12:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) 
// 
//[문제] int 1000개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 1000개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:13:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);


// contiguous - 공간이 연속 / continuous 시간의 연속
// contiguous 의 장점 : accees 의 시간 복잡도 o(1) 
// 
//[문제] int 1000개를 저장할 공간을 만들어라
// [0,99999] 범위의 값을 int 1000개에 집어넣어라.
// 화면에 값을 출력한다.
int main()
{


	int a[100];

	for (int i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:16:27
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	/*for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;*/

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout << max << endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:16:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:16:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[10];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:17:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[10];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;
	cout << endl;
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:17:17
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[10];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;
	cout << endl;
	cout << endl;

	int max = -1000;

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:24:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre(rd());
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:25:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:25:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:25:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	int max = numeric_limits<int>::min();

	for (int i : a)
	{
		if (i > max)
		{
			max = i;
		}
	}

	cout<<max<<endl;
	


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:30:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	{
		int max = numeric_limits<int>::min();

		for (int i : a)
		{
			if (i > max)
			{
				max = i;
			}
		}

		cout << max << endl;
	}
	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:32:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	auto result = max_element(begin(a), end(a));

	cout << result << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:32:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	auto result = max_element(begin(a), end(a));

	cout << *result << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:35:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	auto result = max_element(begin(a), end(a));

	cout << *result << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:36:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	int a[100];

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	
	cout << *max_element(begin(a), end(a)) << endl;

	// STL 에 이미존재하는걸 코딩한것 -> 쓰래기코딩



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:39:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	cout << *max_element(begin(a), end(a)) << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:40:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용


	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	cout << *max_element(a.begin(), a.end()) << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:42:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	sizeof(a);


	for (int& i : a)
	{
		i = uid(dre);
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}
	cout << endl;

	//[문제] a 의 값 중 가장 큰값을 찾아 화면 에 출력 하시오.
	cout << *max_element(a.begin(), a.end()) << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:47:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>
#include <fstream>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	//[문제] 파일 "int값들.txt 에 a 의 int 값을 모두 저장하라.
	// 
	// 
	ofstream out{ "int값들.txt" };

	if (out.is_open())
	{
		for (int i : a)
		{
			out << i;
		}
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:48:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <format> //c++20
#include <print>  //c++23
#include <algorithm>
#include <array>
#include <fstream>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	//[문제] 파일 "int값들.txt 에 a 의 int 값을 모두 저장하라.
	// 
	// 
	ofstream out{ "int값들.txt" };

	if (out.is_open())
	{
		for (int i : a)
		{
			out << i<<endl;
		}
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 2:56:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
#include <array>
#include <fstream>

using namespace std;

random_device rd;
default_random_engine dre;
uniform_int_distribution<int> uid(0, 99999);

int main()
{


	array<int, 100> a; // T[N] 대신 array[T,N] 을 사용

	for (int& i : a)
	{
		i = uid(dre);
	}

	//[문제] 파일 "int값들.txt 에 a 의 int 값을 모두 저장하라.
	// 
	// 
	ofstream out{ "int값들.txt" }; //RAII


	for (int i : a)
	{
		print(out, "{:8}", i);
	};
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:04:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		int num;
		int count{};
		while (in >> num)
		{
			++count;
			cout << "개수"  << endl;
		};


	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:04:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		int num;
		int count{};
		while (in >> num)
		{
			++count;
			cout << "개수" << count  << endl;
		};


	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:05:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		int num;
		int max = numeric_limits<int>::min();
		while (in >> num)
		{
			if (max < num)
			{
				max = num;
			}
		};

		cout << "최댓값:" << max << endl;


	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-12 화요일 오후 3:08:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		/*int num;
		int max = numeric_limits<int>::min();
		while (in >> num)
		{
			if (max < num)
			{
				max = num;
			}
		};*/
		cout << *max_element(istream_iterator<int>{in}, {}) << endl;
		
		

	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:29:21
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 화요일  (2주 1 )                                   //
// 
// 
//    많은 수의 데이터를 처리할 수 있어야 한다.
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

//[문제] "int값들.txt" 에는 몇 개인지 모르는 int 값이 있다.
// 제일 큰값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "int값들.txt" };


	if (in.is_open())
	{
		/*int num;
		int max = numeric_limits<int>::min();
		while (in >> num)
		{
			if (max < num)
			{
				max = num;
			}
		};*/
		cout << *max_element(istream_iterator<int>(in), {}) << endl;
		
		

	}



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:36:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 1; i <= 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:37:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 1; i < 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:37:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 1; i < 100; ++i)
	{
		a[i] = i;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a;

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:38:57
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a{};

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:39:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a{1};

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:39:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

int main()
{
	array<int, 100> a{1,100};

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:40:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

array<int, 100> a;

int main()
{
	

	for (int num : a)
	{
		cout << num << endl;
	}

	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:42:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a;

	for (int& i: a)
	{
		i = i + 1;
	}

	/*for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}*/

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:42:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a;

	for (int& i: a)
	{
		cout << i << endl;
		i = i + 1;
	}

	/*for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}*/

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:44:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};


	for (int i = 0; i < 100; ++i)
	{
		a[i] = i+1;
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:46:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	int count = 0;

	for (int& num : a)
	{
		num = count++;
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:47:00
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	int count = 0;

	for (int& num : a)
	{
		num = ++count;
	}

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:54:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);
	

	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:57:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

	cout << *max_element(a.begin(), a.end()) << endl;
	
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 1:57:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end()-3, 1);

	cout << *max_element(a.begin(), a.end()) << endl;
	
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		out << i << endl;
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:02:40
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		print(out, "{:8}", i);
	}




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:04:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		print(out, "{} ", i);
	}

	//int 100개를 저장하기 위해 필요한 공간은 ?





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:25:21
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	for (int i : a)
	{
		print(out, "{} ", i);
	}

	//int 100개를 저장하기 위해 필요한 공간은 ? 
	// simple 단순그자체로 파일에기록 ( 400바이트 그대로옴겨다적음)-> 저수준 출력
	// 함수 ( 어디에 ,무엇을 ) == 함수(out,a.data(),400);  DMA 코드

	out.write((char*)(a.data()), a.size()*sizeof(int));





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:25:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

		
	for (int i : a)
	{
		print(cout, "{:8}", i);
	}

	ofstream out{"int값들.txt"};

	/*for (int i : a)
	{
		print(out, "{} ", i);
	}*/

	//int 100개를 저장하기 위해 필요한 공간은 ? 
	// simple 단순그자체로 파일에기록 ( 400바이트 그대로옴겨다적음)-> 저수준 출력
	// 함수 ( 어디에 ,무엇을 ) == 함수(out,a.data(),400);  DMA 코드

	out.write((char*)(a.data()), a.size()*sizeof(int));





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:36:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:36:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.




int main()
{
	array<int, 100> a{};

	//int count = 0;

	//for (int& num : a)
	//{
	//	num = ++count;
	//}


	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:43:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;


default_random_engine dre; 
uniform_int_distribution uid;

//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 1000> a{};

	for (int& num : a)
	{
		num = uid(dre);
	}

	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:44:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 100> a{};

	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	//out.write((char*)(a.data()), a.size()*sizeof(int));

	for (int i = 0; i < 100; ++i)
	{
		out << a[i] << endl;
	}
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:44:30
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 100> a{};

	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt"};

	//out.write((char*)(a.data()), a.size()*sizeof(int));

	for (int i = 0; i < 100; ++i)
	{
		out << a[i] << endl;
	}
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:44:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
using namespace std;


//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로 read/write)




int main()
{
	array<int, 100> a{};

	iota(a.begin(), a.end(), 1);

	ofstream out{"int값들.txt",ios::binary};

	//out.write((char*)(a.data()), a.size()*sizeof(int));

	for (int i = 0; i < 100; ++i)
	{
		out << a[i] << endl;
	}
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:46:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로)




int main()
{
	array<int, 1000> a{};

	for (int& num : a)
	{
		num = uid(dre);
	}
	ofstream out{"int값들.txt",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:47:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


// [문제] int 100개 를 저장할 공간을 확보하라.
// int 값을 1부터 시작하는 정수로 채워라.
// 파일 "int값들.txt" 에 기록하라.

//c++ file  OPEN 모드                     I/O LEVEL
// text  모드 : oxoA-> OXOAOD             High(가공)
// binary 모드							  LOW(메모리에 있는그대로)




int main()
{
	array<int, 1000> a{};

	for (int& num : a)
	{
		num = uid(dre);
	}
	ofstream out{"int값들",ios::binary};

	out.write((char*)(a.data()), a.size()*sizeof(int));
	




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:55:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	ifstream in("int값들", ios::binary);


	int buffer[1000] = {};

	in.read((char*)buffer, sizeof(buffer));

	cout << buffer[0] << endl;





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 2:57:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	ifstream in("int값들", ios::binary);


	array<int,1000> buffer;

	in.read((char*)buffer.data(), sizeof(buffer));


	cout << *max_element(buffer.begin(), buffer.end());





	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:00:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	//내가 한 코딩
	// ========================================================================
	//ifstream in("int값들", ios::binary);

	//array<int,1000> buffer;

	//in.read((char*)buffer.data(), sizeof(buffer));


	//cout << *max_element(begin(buffer), buffer.end());
	//==========================================================================

	ifstream fin{ "int값들" ,ios::binary };

	if (!fin.is_open())
	{
		cout << "없다" << endl;
		return 0;
	}

	int num;
	int max= numeric_limits<int>::min();
	for (int i = 0; i < 1000; ++i)
	{
		fin.read((char*) & num, sizeof(num));
		
		if (num > max)
		{
			max = num;
		}
	}

	cout << max << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:01:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	//내가 한 코딩
	// ========================================================================
	ifstream in("int값들", ios::binary);

	array<int,1000> buffer;

	in.read((char*)buffer.data(), sizeof(buffer));


	cout << *max_element(begin(buffer), buffer.end());
	//==========================================================================

	//ifstream fin{ "int값들" ,ios::binary };

	//if (!fin.is_open())
	//{
	//	cout << "없다" << endl;
	//	return 0;
	//}

	//int num;
	//int max= numeric_limits<int>::min();
	//for (int i = 0; i < 1000; ++i)
	//{
	//	fin.read((char*) & num, sizeof(num));
	//	
	//	if (num > max)
	//	{
	//		max = num;
	//	}
	//}

	//cout << max << endl;




	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:03:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid;


//[문제] int 값 1000개를 "int 값들" 에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4000바이트를 기록하였다.
// int 값중 제일 큰값을 찾아 화면에 출력하라.



int main()
{
	//내가 한 코딩
	// ========================================================================
	//ifstream in("int값들", ios::binary);

	//array<int,1000> buffer;

	//in.read((char*)buffer.data(), sizeof(buffer));


	//cout << *max_element(begin(buffer), buffer.end());
	//==========================================================================

	ifstream fin{ "int값들" ,ios::binary };

	if (!fin.is_open())
	{
		cout << "없다" << endl;
		return 0;
	}


	array<int,1000> buffer;

	fin.read(reinterpret_cast<char*>(buffer.data()), sizeof(buffer));

	cout << *max_element(begin(buffer), buffer.end());



	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:08:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num << endl;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre)) };

	int num = { uidNum(dre) };
};


int main()
{
	

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:09:35
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num << endl;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:09:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:11:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	//기록
	ofstream out{ "개들",ios::binary };

	out.write((char*)dogs.data(), sizeof(dogs) * dogs.size());


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-14 목요일 오후 3:12:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] 

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};


int main()
{
	array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	//기록
	ofstream out{ "개들",ios::binary };

	out.write((char*)dogs.data(), sizeof(Dog) * dogs.size());


	save("STL.cpp");

}



=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:51:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	Dog dog;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(&dog), sizeof(dog));
		dog.show();
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:53:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(dogs.data()), sizeof(Dog)*100);
	}

	for (int i = 0; i < 100; ++i)
	{
		dogs[i].show();
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:53:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(dogs.data()), sizeof(Dog)*100);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << i << ":" << *dogs.data() << endl;
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:54:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c<<"  " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary};
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	for (int i = 0; i < 100; ++i)
	{
		fin.read((char*)(dogs.data()), sizeof(Dog)*100);
	}

	for (int i = 0; i < 100; ++i)
	{
		cout << i;
		dogs[i].show();
	}


	
	save("STL.cpp");
	return 0;
}





=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:57:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	fin.read((char*)&dogs, sizeof(Dog) * 100);

	for (const Dog& dog : dogs)
	{
		dog.show();
	}



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 1:57:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 12일 목요일  (2주 2 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 메모리를 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}

	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}
private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog,100> dogs;

	fin.read((char*)&dogs, sizeof(Dog) * 100);

	for (const Dog& dog : dogs)
	{
		dog.show();
	}



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:11:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 몇개인지 모르는 class Dog 객체 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}






private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	//in파일의 크기를 filesystem 을 이용하여 얻는다
	//파일사이즈 /sieof(Dog) -> 100개 
	//runtime 중에  100개가 결정되면 메모리할당? ==> new Dog[100]


	Dog dog;
	int cnt{};

	while (fin >> dog)
	{
		++cnt;
	}

	cout << "읽은 도그의 갯수 :" << cnt << endl;
	dog.show();  // -> 100번 ┚셈 정보



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:20:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	int maxValue = numeric_limits<int>::min();


	//안좋은 코딩의 예시 

	Dog tempDog;

	for (const Dog& dog : dogs)
	{
	/*	cout << dog.Getnum() << endl;*/

		if (dog.Getnum() > maxValue)
		{
			maxValue = dog.Getnum();
			tempDog = dog;
		}
	}

	cout << tempDog << endl;
	cout << maxValue << endl;







	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:39:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	cout << *max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.Getnum() <= b.Getnum();
		}) << endl;






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:42:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	 max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.Getnum() <= b.Getnum();
		 })->show();






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:43:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);


	auto it = max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.Getnum() <= b.Getnum();
		});

	it->show();






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 2:49:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 10000 미만인 Dog 객체는 몇개인지 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);

	int cnt{};
	for (const Dog& dog : dogs)
	{
		if (dog.Getnum() < 10000)
		{
			cnt++;
		}
	}

	cout << cnt << endl;






	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 3:01:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 10000 미만인 Dog 객체는 몇개인지 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);

	auto val = count_if(dogs.begin(), dogs.end(), [](const Dog& a) {
		return a.Getnum() < 10000;
		});

	cout << val << endl;



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-19 화요일 오후 3:02:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 19일 화요일  ( 3주 1 )                                   //
// 
// 
//    FILE I/O text/binary - high/low  level
// 
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidC{ 'a','z' };
uniform_int_distribution uidNum{ -9999,9999 };


// [문제] "개들"에는 class Dog 객체 100개 가 기록되어있다.
// 파일은 binary 모드 이고 , wrtie 함수로 모든 객체를 한번의 write() 기록하였다.
// 파일을 읽어 가장 num 값이 10000 미만인 Dog 객체는 몇개인지 화면에 출력하라.
// class Dog의 멤버는 다음 과 같다. class dog{char c, int num}

class Dog
{

public:
	void show() const
	{
		cout << "c:" << c <<"   " << "num:" << num << endl;
	}

	friend istream& operator>>(istream& is, Dog& dog)
	{
		return is.read((char*)&dog, sizeof(Dog));
	}


	friend ostream& operator<<(ostream& out, const Dog& ohter)
	{
		out << "글자:" << ohter.c << " , 숫자:" << ohter.num;
		return out;
	}


	int Getnum() const
	{
		return num;
	}



private:

	char c = { static_cast<char>(uidC(dre))};

	int num = { uidNum(dre) };
};

int main()
{
	ifstream fin{ "개들" ,ios::binary };
	

	if (not fin)
	{
		cout << "파일을 열수가 없다." << endl;
		return 0;
	}

	array<Dog, 100> dogs;


	fin.read((char*)dogs.data(), sizeof(Dog) * 100);

	auto val = count_if(dogs.begin(), dogs.end(), [](const Dog& a) {
		if (a.Getnum() < 10000)
		{
			return true;
		}
		return false;
		});

	cout << val << endl;



	
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:34:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;



int main()
{
	array<float, 10> a;


	cout << "==" << addressof(a) << endl;

	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:36:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;



int main()
{
	array<float, 10> a;


	cout << "==" << addressof(a) << endl;
	cout << &a << endl;
	cout << a.data() << endl;
	cout << &a[0] << endl;
	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:37:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>

using namespace std;



int main()
{
	array<float, 10> a;


	cout << "==" << addressof(a) << endl;
	cout << &a << endl;
	cout << a.data() << endl;
	cout << &a[0] << endl;
	//for (const auto& v : a)
	//{
	//	cout << addressof(v) << endl;
	//}
	

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:40:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;



int main()
{
	array<float, 10> a;

	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	
	cout << "===========================" << endl;
	string b{ "string" };

	cout << addressof(b) << endl;


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:45:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;



int main()
{
	array<float, 10> a;

	for (const auto& v : a)
	{
		cout << addressof(v) << endl;
	}
	
	cout << "===========================" << endl;
	string b{ "string" };

	cout << addressof(b) << endl;

	cout << "===========================" << endl;
	int c{};
	cout << addressof(c) << endl;

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:50:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test()
{
	int num;
	cout <<"넘주소:"<< & num << endl;
}

int main()
{


	int c{};
	cout << "c주소:" << &c << endl;
	array<float, 10> a;
	string b{ "string" };
	
	test();
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 1:50:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test(int ar)
{
	cout <<"넘주소:"<< &ar << endl;
}

int main()
{


	int c{};
	cout << "c주소:" << &c << endl;
	array<float, 10> a;
	string b{ "string" };
	
	test(c);

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:12:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test()
{
}

int main()
{
	int num;

	test();

	cout << "STACK" << endl;

	cout << "   -num" << addressof(num) << endl;

	cout << "CODE" << endl;

	cout << "   -main" << addressof(main) << endl;
	cout << "   -test" << addressof(test) << endl;
	cout << "   -save" << addressof(save) << endl;

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:16:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


void test()
{
}

int main()
{
	int num;

	test();
	long long val{ 0x7F'FF'FF'FF'FF'FF };

	cout << "사용할수있는 최대 메모리 의 한계" << val << endl;


	cout << "STACK" << endl;

	cout << "   -num" << addressof(num) << endl;

	cout << "CODE" << endl;

	cout << "   -main" << addressof(main) << endl;
	cout << "   -test" << addressof(test) << endl;
	cout << "   -save" << addressof(save) << endl;

	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:22:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	

	cout << "DATA" << endl;
	cout<<"   -global num" << addressof(::num) << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:22:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	

	cout << "DATA" << endl;
	cout<<" -global num" << addressof(::num) << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:23:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	

	cout << "DATA" << endl;
	cout<<" -globalnum " << addressof(::num) << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:25:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "HEAP" << endl;
	int* ptr = new int();
	cout << " -heap " << addressof(ptr) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	
	cout << "DATA" << endl;
	cout<<" -globalnum " << addressof(::num) << endl;

	


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:26:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "HEAP" << endl;
	int* ptr = new int();
	cout << " -heap      " << addressof(ptr) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	
	cout << "DATA" << endl;
	cout<<" -globalnum   " << addressof(::num) << endl;

	


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 2:26:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int num;

int main()
{
	int num;

	cout << "STACK" << endl;

	cout << " -num       " << addressof(num) << endl;

	cout << "HEAP" << endl;
	int* ptr = new int();
	cout << " -heap      " << addressof(ptr) << endl;

	cout << "CODE" << endl;
	cout << " -main      " << addressof(main) << endl;
	
	cout << "DATA" << endl;
	cout<<  "-gnum       " << addressof(::num) << endl;

	


	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:05:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


int a[1'000'000];
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:06:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


int a[1'000'000]{ 1 };
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:10:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int a[1'000'000]; //  초기화 하지않은 전역데이터 (bss) --> 명령어로 대채가능
// int a[1'000'000]{ 1 }; // 초기화 한 전역 데이터
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}




=============================================== 
STL.cpp 2024-03-21 목요일 오후 3:12:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 21일 목요일  ( 3주 2 )                                   //
// 
// 
//    실행파일의 메모리구조 - stack , coe , data ,FREESTORE
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

int a[1'000'000]; //  초기화 하지않은 전역데이터 (bss) --> 명령어로 대채가능
// int a[1'000'000]{ 1 }; // 초기화 한 전역 데이터 -> 메몸리 image 를 실행파일에 붙임 컴파일 속도 느려짐
int main()
{
	cout << a[0] << endl;
	cout << a[999'999] << endl;
	save("STL.cpp");
	return 0;
}

======================================================================================



======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 1:09:20
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"

using namespace std;

//main.cpp의 모든 영문자를 대문자로 바꿔 main대문자.txt에 저장

int main() {

	//ZZZZZ

	save("main.cpp");
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:01:11
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};
void f()
{
	cout << "f 시작" << endl;

	Dog* p = new Dog;

	delete p;
	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:01:55
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};
void f()
{
	cout << "f 시작" << endl;

	shared_ptr<Dog> ptr = make_shared<Dog>();

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:02:06
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};
void f()
{
	cout << "f 시작" << endl;

	shared_ptr<Dog> ptr = make_shared<Dog>();

	ptr.reset();

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:05:41
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) :p{ p } {};
	~SmartPointer() {
		delete p;
	}


private:
	Dog* p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:06:02
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) : _p{ p } {};
	~SmartPointer() {
		delete _p;
	}


private:
	Dog* _p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;


	f();

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:07:55
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) : _p{ p } {};

	~SmartPointer() 
	{
		delete _p;
	}


private:
	Dog* _p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	throw 1234;

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;

	try
	{
		f();
	}

	catch(...)
	{
		cout << "예외를 받았쩌용" << endl;
	}

	save("main.cpp");

	cout << "main 끝" << endl;
}


======================================
main.cpp 저장 시간: 2024-03-26 화요일 오후 3:08:07
======================================

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "Save.h"
#include <memory>
#include <numeric>
#include <thread>
/*
* 4주 2일
* 
* free sotre - RAII
* C++ 언어에서 사용하지 않도록 권고 하는 3가지 
* - char*				--> string
* - T[N]				--> array[T,N]
* - T*(raw pointer)     --> smartPointer [ unique_ptr , shared_ptr , weak_ptr ]
* 
*-	memory manger -> LINKED LIST
* 
*/
// 1. memory leak
// 2. delete[] p ,delete[] p; ( 댕글링 )
// 3. 제어경로가 복잡해 질 경우 문제가 발생할수 있다.

// -> RAII
using namespace std;
////
// 프리스토어 ->40G 쓸수있다 . 
// 데이터 ->2G 맥스
// 
// 
//해결하는 코드를 답지에 적어라

class Dog
{

public:
	Dog() { cout << "도그 생성" << endl; }
	~Dog() { cout << "도그 소멸" << endl; }
};

class SmartPointer
{

public:
	SmartPointer(Dog* p) : _p{ p } {};

	~SmartPointer() 
	{
		delete _p;
	}


private:
	Dog* _p;
};
void f()
{
	cout << "f 시작" << endl;

	SmartPointer sm(new Dog);

	throw 1234;

	cout << "f 끝" << endl;
}
int main() 
{
	cout << "main 시작" << endl;

	try
	{
		f();
	}

	catch(...)
	{
		cout << "예외를 받았쩌용" << endl;
	}

	save("main.cpp");

	cout << "main 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:37:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	~Dog() { cout << "dog 소멸" << endl; }
};

int main()
{
	unique_ptr<Dog> p(new Dog);





	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:43:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	~Dog() { cout << "dog 소멸" << endl; }
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	unique_ptr<Dog[]> p(new Dog[10]);





	save("STL.cpp");
	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:44:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	~Dog() { cout << "dog 소멸" << endl; }
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	unique_ptr<Dog[]> p(new Dog[10]);





	save("STL.cpp");

	throw 1;



	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:50:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	Dog(int b) {
		a = b;
		cout << "dog 생성" << endl; 
	}
	~Dog() { cout << "dog 소멸" << endl; }

	int a = 10;
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	// 이 main() 은 문제없지만 불편하다. -> new 와 짝이 맞는 delete 가없다?

	unique_ptr<Dog[]> p = make_unique<Dog[]>(10);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:50:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }
	Dog(int b) {
		a = b;
		cout << "dog int 생성" << endl; 
	}
	~Dog() { cout << "dog 소멸" << endl; }

	int a = 10;
};

int main()
{
	
	// 도그 10마리를 만들어봐라
	// 이 main() 은 문제없지만 불편하다. -> new 와 짝이 맞는 delete 가없다?

	unique_ptr<Dog[]> p = make_unique<Dog[]>(10);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:54:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t = isupper(t);
		}
		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:55:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t += 32;
		}

		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:55:58
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t += 32;
		}

		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 1:56:01
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp");
	ofstream out{"STL대문자.txt"};

	char t = {};


	while (in>>t)
	{
		if (islower(t) == true)
		{
			t += 32;
		}

		out << t;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:07:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{
	
	ifstream in("STL.cpp"s,ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{"STL대문자.txt",ios::binary};
	char c;

	while (in.read(&c, sizeof(char)))
	{
		c=toupper(c);
		cout << c;

		out << c;
	}



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:17:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자.txt",ios::binary };


	transform(istreambuf_iterator<char>(in), {},
		ostreambuf_iterator<char>{out}, [](char c) 
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:18:00
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자2.txt",ios::binary };


	transform(istreambuf_iterator<char>(in), {},
		ostreambuf_iterator<char>{out}, [](char c) 
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:20:11
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자.txt",ios::binary };

	transform(istreambuf_iterator<char>(in), {},
		ostreambuf_iterator<char>{cout}, [](char c) 
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:21:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
// 
//  unique_ptr 사용해보자 -자원을 독점 소유(owneship)  
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


//[문제] "STL.cpp"  을 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt" 에 저장하라.

class Dog
{
public:

	Dog() { cout << "dog 생성" << endl; }

	~Dog() { cout << "dog 소멸" << endl; }

};

int main()
{

	ifstream in("STL.cpp"s, ios::binary);

	if (not in)
	{
		return 123123123213;
	}


	ofstream out{ "STL대문자.txt",ios::binary };

	transform(istream_iterator<char>(in), {},
		ostream_iterator<char>{cout}, [](char c)
		{
			return toupper(c);
		}
	);



	save("STL.cpp");

	

	cout << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:25:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>

using namespace std;


int main()
{




	save("STL.cpp");

	

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 2:55:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.

int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}

int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), compare);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:02:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), [](const void* a, const void* b)
		{
			return (*(int*)a-*(int*)b);
		}
	);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:07:49
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int 함수(const void* a, const void* b) {
	return (*(int*)-*(int*)b);
}

int compare(const void* a, const void* b) {
	return (*(int*) - *(int*)b);
}



int main()
{
	array<int, 100> a;

	/*for (int& i : a)
	{
		i = uid(dre);
	}*/

	cout << typeid(compare).name() << endl;

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	/*qsort(a.data(), a.size(), sizeof(int), [](const void* a, const void* b)
		{
			return (*(int*)a-*(int*)b);
		}
	);





	for (int i : a)
	{
		print("{:8}", i);
	}*/


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:10:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	/*for (int& i : a)
	{
		i = uid(dre);
	}*/

	int (*함수)(const void*, const void*) = compare;

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), 함수);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-03-28 목요일 오후 3:11:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 3월 28일 목요일  ( 4주 2 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//    
//-------------------------------------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
// C의 qsort 를 사용하여 오름차순으로 정렬하라. 
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	int (*함수)(const void*, const void*) = compare;

	//c 함수이지만 generic 함수이다.
	// contigus 메모리만 가능
	// 비교함수를 받을 항상 포인트를 전달해줌. 
	qsort(a.data(), a.size(), sizeof(int), 함수);





	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 1:37:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}

	//int (*함수)(const void*, const void*) = compare;

	//qsort(a.data(), a.size(), sizeof(int), 함수);

	sort(a.begin(), a.end());


	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 1:39:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), [](int& n1, int&n2) {return n1>n2;});


	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 1:39:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.


int compare(const void* a, const void* b) {
	return (*(int*)a - *(int*)b);
}



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), [](int& n1, int&n2) {return n1<n2;});


	for (int i : a)
	{
		print("{:8}", i);
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:00:19
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.
int cnt{};





int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), [](int a, int b){
			return a > b;
		});



	for (int i : a)
	{
		print("{:8}", i);
	}



	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:08:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
// 
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.
int cnt{};

class Dog
{

public:


	bool operator()(int a, int b)
	{
		return a > b;
	}

	//friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
	//	return os;
	//}

};



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}



	sort(a.begin(), a.end(), Dog{});

	//람다의 장점 : 가독성이 대폭 상승 하였다.
	// 람다는 code segment 의 영역에 존재한다. 


	for (int i : a)
	{
		print("{:8}", i);
	}



	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:20:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type -> 정렬 예제에서 시작
//   
//    
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uid(1, 10000);

//[문제] int 100개를 저장할 공간을 확보하라.
//int 100 개의 값을 [1,10000] 까지 랜덤값으로 설정하라.
//int 값 100개를 std::sort 를 사용하여 오름차순으로 정렬하라.
//정렬 결과를 한줄에 10개씩 화면에 출력하라.
int cnt{};

class Dog
{

public:


	bool operator()(int a, int b)
	{
		cnt++;
		return a > b;
	}

	void ShowResult() const
	{
		cout << endl;
		cout << cnt << "번 비교함수 호출 됨" << endl;
	}

private:

	static int cnt;

};

int Dog::cnt = 0;



int main()
{
	array<int, 100> a;

	for (int& i : a)
	{
		i = uid(dre);
	}


	
	Dog t;
	sort(a.begin(), a.end(),t);

	//람다의 장점 : 가독성이 대폭 상승 하였다.
	// 람다는 code segment 의 영역에 존재한다. 


	for (int i : a)
	{
		print("{:8}", i);
	}

	t.ShowResult();



	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:30:03
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{
	//함수를 define 한것임
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	//함수를 define  하고 호출한것
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	}();


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:30:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{
	//함수를 define 한것임
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	//함수를 define  하고 호출한것
	[]() {
		cout << "안녕 난 람다라고해! " << endl;
	}();

	//함수를 define  하고 호출한것
	[](int a,int b) {
		cout << "안녕 난 람다라고해! "<<a<<" " << b << endl;
	}(4,5);

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:32:51
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{

	//함수를 define  하고 호출한것
 	auto 람다 =[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	cout <<"람다의 정체" << typeid(람다).name() << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:37:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;



int main()
{

	//함수를 define  하고 호출한것
 	auto 람다1 =[]() {
		cout << "안녕 난 람다라고해! " << endl;
	};

	auto 람다2 = []() {
		cout << "안녕 난 람다라고해! " << endl;
		};
	cout << "람다1의 정체" << typeid(람다1).name() << endl;
	cout << "람다2의 정체" << typeid(람다2).name() << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:38:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;


auto 람다1 = []() {
	cout << "안녕 난 람다라고해! " << endl;
	};

auto 람다2 = []() {
	cout << "안녕 난 람다라고해! " << endl;
	};

int main()
{

	
	cout << "람다1의 정체" << typeid(람다1).name() << endl;
	cout << "람다2의 정체" << typeid(람다2).name() << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:51:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;

void f(int(*x)(int ,int))
{
	cout <<x(3,5) <<endl;
}

int x(int a, int b)
{
	return a * b;
}

int main()
{
	
	f(x);
	
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:54:30
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
//-------------------------------------------------------------------------------------------------------



#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;

void f(int(*x)(int ,int))
{
	cout <<x(3,5) <<endl;
}

int x(int a, int b)
{
	return a * b;
}

int main()
{

	f([](int, int) ->int {return 333; });
	
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 2:58:40
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
//  callable type [무한대] -> 정렬 예제에서 시작
//   
//	많은 데이터를 정렬할때 - 정렬기준을 어떻게 sort 함수에 전달하지???
//  1. 함수포인터 int (*함수)(const void*, const void*) = compare;
//	2. 람다
//  3. 함수 객체 - ()연산자를 오버로딩한 클래스 객체
//     상태를 가질수 있다.
// --> 모든 호출가능 타입을 대표하는 클래스 -> function
// 
//-------------------------------------------------------------------------------------------------------


#include <functional>
#include <iostream>
#include "save.h"
#include <array>
#include <fstream>
#include <print>
#include <numeric>
#include <random>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <print>
using namespace std;

void f(function<int(int,int)>x)
{
	cout <<x(3,5) <<endl;
}

int x(int a, int b)
{
	return a * b;
}

int main()
{

	f([](int, int) ->int {return 333; });
	f(x);

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-02 화요일 오후 3:10:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{

	size_t len{};
	unique_ptr<char[]> p{};

public:

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}




	char *ptr;
};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	//String t = s;
	cout << s << endl;
	//cout << t << endl;
	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 1:41:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{


public:

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	String(const String& other)
	{
		len = other.len;
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}


	
	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	
	String v = s;

	cout << s << endl;
	cout << v << endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 1:52:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{


public:

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	String(const String& other)
	{
		len = other.len;
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}



	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	
	String v = s;

	cout << s << endl;
	cout << v << endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 1:53:50
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>

using namespace std;

class String
{


public:
	String() = default;

	String(const char* s) : len(strlen(s))
	{
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	String(const String& other)
	{
		len = other.len;
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}

	


	friend ostream& operator<<(ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

};


int main()
{

	String s{ "STL 공부를 위한 클래스" };
	
	String v = s;

	cout << s << endl;
	cout << v << endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:14:17
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"







int main()
{

	String s{ "STL 공부를 위한 클래스" };
	String t;
	t = s;
	std::cout << s << std::endl;
	std::cout << t << std::endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:14:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"







int main()
{

	String s{ "STL 공부를 위한 클래스" };
	String t;
	t = s;
	std::cout << s << std::endl;
	std::cout << t << std::endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:15:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"







int main()
{

	String s{ "STL 공부를 위한 클래스" };
	String t;
	t = s;
	std::cout << s << std::endl;
	std::cout << t << std::endl;

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:18:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:18:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:18:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:19:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>






int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:22:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:22:59
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:23:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:24:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// 
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;

//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	for (String& s : a)
	{
		cout << s << endl;
	}

	std::sort(a.begin(), a.end(),String::test);

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 2:24:09
=============================================== 

#pragma once
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	String(const String& other);

	static int test(const String& a, const String& b);


	String& operator=(const String& rhs);


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 2:24:09
=============================================== 

#include "Mystring.h"
size_t String::uid{};

String::String():id(uid++)
{
	
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	
}

String::~String()
{
	cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}

String::String(const char* s):id(uid++)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	cout << "[" << id << "] - 생성자 생성,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}

String::String(const String& other):id(uid++)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	cout << "[" << id << "] - 복사 생성,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}

int String::test(const String& a, const String& b)
{
	return a.len < b.len;
}



String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
	cout << "주소 :" << static_cast<void*>(p.get()) << endl;
}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:55:04
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;


//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"2024년" ,"4월","4일","목요일", "즐거운 STL"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 2:55:04
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 2:55:04
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 2:56:29
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;


//문제 a를 길이 오름차순으로 정렬하다.


int main()
{

	array<String, 5> a
	{
		"1" ,"333","555","777777", "99999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 2:56:29
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 2:56:29
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:03:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281329" ,"332342343","553243242345","7772343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetPtr() < b.GetPtr();
		});


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:03:32
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:03:32
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:06:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281329" ,"332342343","553243242345","7772343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:06:52
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:06:52
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:07:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281329" ,"332342343","553243242345","7772343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:07:08
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:07:08
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:07:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281435329" ,"33233455142343","553123279243242345","7778972343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}


	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:07:22
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:07:22
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-04 목요일 오후 3:09:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 2일 목요일  ( 5주 1 )                                   //
// Main
// 4-25 중간시험
// 
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
#include <array>
#include <algorithm>
using namespace std;




int main()
{

	array<String, 5> a
	{
		"1213281435329" ,"33233455142343","553123279243242345","7778972343242777", "991211111111999999"
	};
	
	//for (String& s : a)
	//{
	//	cout << s << endl;
	//}
	
	관찰 = true;
	std::sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});
	관찰 = false;

	관찰 = true;
	for (const String& s : a)
	{
		sort(s.GetPtr(), s.GetPtr() + s.GetLen());
	}
	관찰 = false;

	//[문제] a의 각 string 이 관리하는 글자를 오름차순으로 정렬하라.

	for (String& s : a)
	{
		cout << s << endl;
	}

	save("STL.cpp");
	save("MyString.h");
	save("MyString.cpp");
}




=============================================== 
MyString.h 2024-04-04 목요일 오후 3:09:31
=============================================== 

#pragma once
///////////////////////////////////////////////////////////
// 헤더파일
///////////////////////////////////////////////////////////
#include <iostream>
#include "save.h"
#include <memory>
#include <cstring>
#include "Mystring.h"
using namespace std;
extern bool 관찰;

class String
{

public:
	// 이두함수는 관찰을 위해 생성한것 만들필요가 전혀없다.
	String();

	~String();
	
	String(const char* s);

	//복사생성자
	String(const String& other);
	//복사할당연산자
	String& operator=(const String& rhs);

	//2024.4.4 이동생성자 // 이동할당연산자
	String(String&&);
	String& operator=(String&&);


	size_t GetLen() const { return len; }
	char* GetPtr() const { return p.get(); }


	friend std::ostream& operator<<(std::ostream& os, const String& s)
	{
		for (size_t i = 0; i < s.len; ++i)
		{
			os << s.p.get()[i];
		}

		return os;
	}

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	static size_t uid;
	size_t id{};


};


=============================================== 
MyString.cpp 2024-04-04 목요일 오후 3:09:31
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:23:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// Container 에 대해 공부 해보자~
// STL : Container [자료구조]               / Algorithm[알고리즘] 
// 1.Sequence Container                       1.Non-modifying Alogrithm
// 2.Associative Container					  2. Modifying
// 3.Unordered Container                      3. Sort
// Adaptor => Stack,Queue,FlatSet,FlatMap     numeric,
// 
// find -> 1. 첫원소? (being) 2. 다음원소? ++ 3. 마지막? (end) 로 통일 => iterator [디자인 패턴]
// OCP =>  자료구조가 추가되더라도 똑같이 알고리즘이 작동?
//  Sequence => 1. array[T,N] 2. vector<T> 3. deque<T> (덱)[양향확장] 4.forward_list<T> 5.list<T>   
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
using namespace std;

int main()
{


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:36:38
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a;



	//iterator 의 기본동작은 다음과같다
	array<int, 10>::iterator p = a.begin();
	p.operator++();
	p++;
	array<int, 10>::iterator e = a.end();




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:38:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a;



	//iterator 의 기본동작은 다음과같다
	for (array<int, 10>::iterator p = a.begin(); p != a.end(); p.operator++())
	{
		cout << p.operator*() << endl; 
	};




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:38:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a{ 1,2,3,4,5,6,7,8,9 };



	//iterator 의 기본동작은 다음과같다
	for (array<int, 10>::iterator p = a.begin(); p != a.end(); p.operator++())
	{
		cout << p.operator*() << endl; 
	};




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:38:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
using namespace std;

int main()
{
	array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};



	//iterator 의 기본동작은 다음과같다
	for (array<int, 10>::iterator p = a.begin(); p != a.end(); p.operator++())
	{
		cout << p.operator*() << endl; 
	};




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:47:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	//array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};
	/*list<int> a{ 1,2,3,4,5,6,7,8,9 };*/
	set<int> a{ 1,6,7,4,2,3,2,1,2 };


	//iterator 의 기본동작은 다음과같다
	for(auto p = a.begin(); p != a.end(); ++p)
	{
		cout << *p << endl; 
	};

	for (auto& i : a)
	{
		cout << i << endl;
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:47:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	//array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};
	/*list<int> a{ 1,2,3,4,5,6,7,8,9 };*/
	set<int> a{ 1,6,7,4,2,3,2,1,2 };


	//iterator 의 기본동작은 다음과같다
	for(auto p = a.begin(); p != a.end(); ++p)
	{
		cout << *p << endl; 
	};

	//range based for -> range for 
	for (auto& i : a)
	{
		cout << i << endl;
	}


	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 2:50:02
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	//array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};
	/*list<int> a{ 1,2,3,4,5,6,7,8,9 };*/
	set<int> a{ 1,6,7,4,2,3,2,1,2 };


	//iterator 의 기본동작은 다음과같다
	for(auto p = a.begin(); p != a.end(); ++p)
	{
		cout << *p << endl; 
	};

	//range based for -> range for 
	for (auto& i : a) 
	{
		cout << i << endl;
	}
	//==> 컴파일러가 장난쳐줌
	// syntatic sugar

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-09 화요일 오후 3:02:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
using namespace std;

int main()
{
	array<int, 10> a{ 1,2,3,4,5,6,7,8,9 ,10};


	try
	{
		a.at(-20);
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;
	}




	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:38:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:39:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[0];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:40:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[i];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}



	

	save("STL.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:42:05
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 9일 화요일  ( 6주 1 )                                   //
// Main
// 4-25 중간시험
// 
// STL Conatiner -> Containers are objects that store other objects. 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
using namespace std;

int main()
{
	array<String, 50> a;

	//[문제] "STL.cpp" 의 단어(공백으로구분) 를 A 에 저장 하라.
	// 길이 오름차순으로 A를 정렬하라.
	// 화면에 출력하라.

	ifstream in{ "STL.cpp" };

	for (int i = 0; i < 50; ++i)
	{
		in >> a[i];
	}
	
	for (const String& i : a)
	{
		cout << i << endl;
	}


	sort(a.begin(), a.end(), [](const String& a, const String& b)
		{
			return a.GetLen() < b.GetLen();
		});


	

	save("STL.cpp");
	save("Mystring.cpp");

}




=============================================== 
Mystring.cpp 2024-04-11 목요일 오후 1:42:05
=============================================== 

#include "Mystring.h"

///////////////////////////////////////////////////////////
// cpp 파일 2024 .4.4 STL 동작 을 관찰하기위함
// 2024 . 4 .4  관찰 메세지 
///////////////////////////////////////////////////////////


size_t String::uid{};
extern bool 관찰{ false };

String::String():id(++uid)
{
	if (관찰)
	{
		cout << "[" << id << "] - 디폴트 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::~String()
{
	if (관찰)
	{
		cout << "[" << id << "] - 소멸자 호출,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const char* s):id(++uid)
{
	len = strlen(s);
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰)
	{
		cout << "[" << id << "] - 생성자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String::String(const String& other):id(++uid)
{
	len = other.len;
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}





String& String::operator=(const String& rhs)
{
	if (this == &rhs)
		return *this;

	len = rhs.len;
	p.release();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), rhs.p.get(), len);

	if (관찰)
	{
		cout << "[" << id << "] - 복사 할당 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;
}

String::String(String&& other)
	:len(other.len),id(++uid)
{
	p.reset(other.p.get());
	other.p.release();
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}
}

String& String::operator=(String&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.reset(other.p.release());
	other.len = 0;

	if (관찰)
	{
		cout << "[" << id << "] - 이동할당연산자 생성,갯수:" << len;
		cout << "주소 :" << static_cast<void*>(p.get()) << endl;
	}

	return *this;

}


//입출력함수 오버로딩
std::ostream& operator<<(std::ostream& os, const String& s)
{
	for (size_t i = 0; i < s.len; ++i)
	{
		os << s.p.get()[i];
	}

	return os;
}

std::istream& operator>>(istream& is, String& other)
{

	std::string str;
	is >> str;



	other.len = str.size();
	other.p = make_unique<char[]>(other.len);
	memcpy(other.p.get(), str.data(), other.len);

	return is;
	//std::string str;
	//// Read string using >> operator
	//is >> str;

	//// Allocate memory for the string in String object
	//other.p.reset(new char[str.length() + 1]);

	//// Copy string content to the allocated memory
	//memcpy(other.p.get(), str.c_str(), str.length() + 1);

	//// Update length
	//other.len = str.length();

	//return is;


}

=============================================== 
STL.cpp 2024-04-11 목요일 오후 1:48:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{


	vector<int> v(1'0000'0000,3);

	for (int num : v | views::drop(v.size()-100))
	{
		cout << num << " ";
	}

	cout << endl;
	cout << sizeof(v) << endl;




	save("STL.cpp");
	//save("Mystring.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:01:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");



	//for (int num : v | views::drop(v.size()-1))
	//{
	//	cout << num << " ";
	//}

	//cout << endl;
	//cout << sizeof(v) << endl;




	save("STL.cpp");
	//save("Mystring.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:03:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");



	//for (int num : v | views::drop(v.size()-1))
	//{
	//	cout << num << " ";
	//}

	//cout << endl;
	//cout << sizeof(v) << endl;




	save("STL.cpp");
	//save("Mystring.cpp");

}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:15:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");

	cout << endl<< "원소추가------------------" << endl;
	v.push_back("4월");
;

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:16:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;

	v.push_back("2024년");
	cout << v.capacity() << endl;

	cout << endl<< "원소추가------------------" << endl;
	v.push_back("4월");
;	cout << v.capacity() << endl;

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 2:53:24
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;
	v.reserve(10); //공간을 미리 마련하고 사용하자 - 새 메모리를 확보하기 위한 노력이 필요없음

	v.push_back("2024년");


	cout << endl<< "원소추가------------------" << endl;
	v.push_back("4월");

	cout << endl << "원소추가------------------" << endl;
	v.push_back("11일");

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-11 목요일 오후 3:02:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 111일 목요일  ( 6주 2 )                                   //
//
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

int main()
{

	관찰 = true;

	vector<String> v;
	v.reserve(10); //공간을 미리 마련하고 사용하자 - 새 메모리를 확보하기 위한 노력이 필요없음

	v.emplace_back("2024년");
	// push_back 의 시간 복잡도 o(1) 이다 .[ 단 이사가지않는다면  ] (armotized constant time)




	cout << endl<< "원소추가------------------" << endl;
	v.emplace_back("4월");

	cout << endl << "원소추가------------------" << endl;
	v.emplace_back("11일");

	save("STL.cpp");
	//save("Mystring.cpp");
	cout << endl << "메인 끝" << endl;
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 1:35:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	vector<String> v;

	v.push_back("벡터입니다.");

	cout << endl << endl;

	v.push_back("벡터는 dynamic array 입니다.");


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:01:13
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	vector<String> v;

	v.reserve(20);

	v.emplace_back("벡터입니다.");

	cout << endl << endl;

	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	v.emplace_back("벡터는 dynamic array 입니다.");
	cout << endl << endl;
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:03:59
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:05:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(5);

	for (int i = 0; i < 5; ++i)
	{
		v.push_back(1);
	}


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:05:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(5);

	for (int i = 0; i < 5; ++i)
	{
		v.push_back(123);
	}


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:06:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(123);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	for (int i = 0; i < 123; ++i)
	{
		v.push_back(1);
	}
	v.push_back(1);
	cout << endl;


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:07:04
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(123);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	for (int i = 0; i < 123; ++i)
	{
		v.push_back(1);
	}
	cout << endl;


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	v.push_back(1);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:07:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	/*v.push_back(5);*/
	v.reserve(123);

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	for (int i = 0; i < 123; ++i)
	{
		v.push_back(1);
	}
	cout << endl;


	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	v.push_back(1);

	cout << endl;

	cout << v.size() << endl;
	cout << v.data() << endl;
	cout << v.capacity() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:17:27
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	cout << "vector<int> 최대 몇개?" << v.max_size() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:18:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	cout << "vector<int> 최대 몇개?" << v.max_size() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:18:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v;

	cout << "vector<int> 최대 몇개?" << v.max_size() << endl;

	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:22:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };

	for (int num : {1, 3, 5, 7, 8})
	{
		cout << num << endl;
	}



	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:23:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };




	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:23:23
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };




	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:23:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
using namespace std;

//문제 키보드에서 입력한 int 값의 합계와 평균값을 출력하라.

int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };




	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:25:47
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,6,7 };

	remove(v.begin(), v.end(), 3);

	


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:26:09
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	remove(v.begin(), v.end(), 3);

	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:26:34
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:27:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:28:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:28:46
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:28:57
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:12
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:35
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:44
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:29:54
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:30:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 6);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:34:06
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	/*for (auto& i : v)
	{
		cout << i << endl;
	}*/


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:35:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,3,3,3,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:35:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,3,3,4,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:36:41
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,3,3,4,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:36:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,4,4,4,3,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:37:01
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,3,3,4,5,3,4,4,4,3,3};

	auto it =remove(v.begin(), v.end(), 4);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:39:39
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 4);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:41:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 4);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:41:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5};

	auto it =remove(v.begin(), v.end(), 4);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	//for (auto& i : v)
	//{
	//	cout << i << endl;
	//}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:08
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	//for (auto& i : v)
	//{
	//	cout << i << endl;
	//}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:16
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:25
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:42
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:42:57
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:43:13
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:43:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,3,2,3};

	auto it =remove(v.begin(), v.end(), 3);
	/*cout << *it << endl;*/
	v.erase(it,v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:44:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3};

	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:45:53
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					   // = { 1,2,4,5,2,4,2,3,4
	auto it =remove(v.begin(), v.end(), 3);
	cout << *it << endl;
	/*v.erase(it,v.end());*/


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:46:37
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					
	v.erase(remove(v.begin(), v.end(), 3),v.end());


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:47:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					
	v.erase(remove(v.begin(), v.end(), 3),v.end());

	erase(v, 3);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:47:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <list>
#include <algorithm>
#include <set>
#include <fstream>
#include <vector>
#include <ranges>
#include <algorithm>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v = { 1,2,3,4,5,3,2,3,4};
					
	/*v.erase(remove(v.begin(), v.end(), 3),v.end());*/

	erase(v, 3);


	for (auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:53:15
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v;

	v.reserve(100);

	iota(v.begin(), v.end(), 1);
	
	for (int num : v)
	{
		print("{:8}",num );
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 2:58:40
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v(100);

	iota(v.begin(), v.end(), 1);
	

	auto it =remove_if(v.begin(), v.end(), [](const int& n1)
		{
			return (n1 % 2 != 0);
		});
	
	
	v.erase(it, v.end());

	for (int num : v)
	{
		print("{:8}", num);
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:01:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
using namespace std;

//문제에서 3을 제거하라.
int main()
{

	관찰 = true;
	
	std::vector<int> v(100);

	iota(v.begin(), v.end(), 1);
	

	/*auto it =remove_if(v.begin(), v.end(), [](const int& n1)
		{
			return (n1 % 2 != 0);
		});*/

	erase_if(v, [](const int& n1) {
		return n1&1;
		});

	for (int num : v)
	{
		print("{:8}", num);
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:14:56
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	char ch = 'a';

	cout << (int)ch;

	

	

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:21:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	std::map<char, int> Map;

	for (int i = 'a'; i < 'z'; ++i)
	{
		Map[i] = 0;
	}

	ifstream in{ "STL.cpp" };

	char ch;

	while (in >> ch)
	{
		if (ch >= 'a' && ch <= 'z')
		{
			Map[ch] += 1;
		}
	}
	
	
	for (auto& pair : Map)
	{
		cout << "문자:"<<pair.first << " , 갯수:" << pair.second << endl;
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-16 화요일 오후 3:21:31
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 16일 목요일  (7 주 1 )                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	std::map<char, int> Map;


	ifstream in{ "STL.cpp" };

	char ch;

	while (in >> ch)
	{
		if (ch >= 'a' && ch <= 'z')
		{
			Map[ch] += 1;
		}
	}
	
	
	for (auto& pair : Map)
	{
		cout << "문자:"<<pair.first << " , 갯수:" << pair.second << endl;
	}

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 1:42:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;

//문제에서 3을 제거하라.
//[문제] "STL.cpp" 에있는 소문자의 출현 횟수를 다음과 같이 출력하라.
// a-10
// b-3
// c-0
//중간생략....
// z-2


int main()
{

	관찰 = true;
	
	array<int, 26> alphaNum{};


	ifstream in{ "STL.cpp" };

	if (not in)
	{
		return 0;
	}

	char c;
	while (in >> c)
	{
		if (islower(c))
		{
			alphaNum[c - 'a']++;
		}
	}

	for (int i = 0; i < 26; ++i)
	{
		cout << static_cast<char>('a' + i) << "-" << alphaNum[i] << endl;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/*std::map<char, int> Map;

	

	ifstream in{ "STL.cpp" };

	char ch;

	while (in >> ch)
	{
		if (ch >= 'a' && ch <= 'z')
		{
			Map[ch] += 1;
		}
	}
	
	
	for (auto& pair : Map)
	{
		cout << "문자:"<<pair.first << " , 갯수:" << pair.second << endl;
	}*/

	
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 1:55:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;



//[문제] 
// 키보드에서 입력한 단어를 오름차순으로 정렬후 출력하라.



int main()
{

	vector<int>v{ 1,2,3,4,5 };

	erase(v, 3);

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:12:10
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	erase(v, "3");

	//auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	//	return s.GetPtr() == "안녕";
	//	});

	//v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:12:20
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	erase(v, "3");

	//auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	//	return s.GetPtr() == "안녕";
	//	});

	//v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:14:04
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	//erase(v, "3");

	auto it = remove_if(v.begin(), v.end(), [](const String& s) {
		return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
		});

	v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:14:07
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{

	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.

	//erase(v, "3");

	auto it = remove_if(v.begin(), v.end(), [](const String& s) {
		return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
		});

	v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:15:36
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.
	관찰 = true;
	erase(v, "3");
	관찰 = false;
	////auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	////	return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
	////	});

	////v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i.GetPtr() << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:15:43
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","3","4","5"};
	
	//[문제] v 에서 3을 제거하라.
	관찰 = true;
	erase(v, "3");
	관찰 = false;
	////auto it = remove_if(v.begin(), v.end(), [](const String& s) {
	////	return equal(s.GetPtr(), s.GetPtr() + s.GetLen(), "3");
	////	});

	////v.erase(it, v.end());

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:22
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "2");
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:45
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	cout << *it << endl;
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:19:52
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	cout << *it << endl;
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:21:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
using namespace std;




int main()
{


	vector<String>v{ "1","2","4","4","4","5"};
	
	auto it = find(v.begin(), v.end(), "4");
	v.insert(it, "3");

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:30:55
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - vector(dynamic array - []operator)
// 
// 데이터무결성 => 벡터는 이사를 갈때 이동생성자를 사용하지않고 복사를 해서 이사를감.
// But noexcept 를 붙어주면 이동생성자를 이용함.
// 
// pushback(T) => amortized O(1)
// erase , insert - O(N)
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <array>
#include <numeric>
#include <algorithm>
#include <fstream>
#include <vector>
#include <algorithm>
#include <print>
#include <map>
#include <list>
using namespace std;




int main()
{


	list<String>v{ "1","22","4444","55555"};
	

	//관찰 = true;
	auto it = find(v.begin(), v.end(), "4");
	//auto p = v.begin();
	//++p;
	//++p;

	관찰 = true;
	v.emplace(it, "3");
	관찰 = false;

	for (const auto& i : v)
	{
		cout << i << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:44:26
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:44:33
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}


	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:45:28
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3,4 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}

	cout << endl;
	d.push_back(5);
	cout << endl;

	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:45:48
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3,4 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}

	cout << endl;
	d.push_back(5);
	cout << endl;

	for (int i = 0; i < d.size(); ++i)
	{
		cout << &d[i] << endl;
	}
	save("STL.cpp");
}




=============================================== 
STL.cpp 2024-04-18 목요일 오후 2:47:32
=============================================== 

//-------------------------------------------------------------------------------------------------------
//                          2024. 1학기 STL 4월 18일 목요일  (7 주 2)                                   //
//
// 4월 25일 (8주 2일) - 중간시험
// STL container - Sequence - deque
// 덱->
// push_back , push_front => o(1) 알고리즘
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "Mystring.h"
#include <deque>
using namespace std;




int main()
{
	deque<int> d{ 1,2,3,4 };
	
	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << "--" << &d[i] << endl;
	}

	cout << endl;
	d.push_back(5);
	cout << endl;

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i]<<"--" << &d[i] << endl;
	}

	d.push_front(0);

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << "--" << &d[i] << endl;
	}

	save("STL.cpp");
}


